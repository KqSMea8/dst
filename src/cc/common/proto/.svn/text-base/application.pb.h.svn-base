// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: application.proto

#ifndef PROTOBUF_application_2eproto__INCLUDED
#define PROTOBUF_application_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "dstream_proto_common.pb.h"
#include "pn.pb.h"
// @@protoc_insertion_point(includes)

namespace dstream {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_application_2eproto();
void protobuf_AssignDesc_application_2eproto();
void protobuf_ShutdownFile_application_2eproto();

class User;
class AppID;
class FileConfig;
class Processor;
class Publish;
class BigpipePub;
class Subscribe;
class LocalSub;
class ScribeSub;
class BigpipeSub;
class HdfsSub;
class ProcessorSub;
class FakeSub;
class Topology;
class FlowControl;
class Application;
class BackupPEID;
class BackupPE;
class logConfig;
class ProcessorElement;
class SubPoint;

enum ProcessorRole {
  IMPORTER = 0,
  EXPORTER = 1,
  WORK_PROCESSOR = 2
};
bool ProcessorRole_IsValid(int value);
const ProcessorRole ProcessorRole_MIN = IMPORTER;
const ProcessorRole ProcessorRole_MAX = WORK_PROCESSOR;
const int ProcessorRole_ARRAYSIZE = ProcessorRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessorRole_descriptor();
inline const ::std::string& ProcessorRole_Name(ProcessorRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessorRole_descriptor(), value);
}
inline bool ProcessorRole_Parse(
    const ::std::string& name, ProcessorRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessorRole>(
    ProcessorRole_descriptor(), name, value);
}
enum AppStatus {
  SUBMIT = 0,
  RUN = 1,
  KILL = 2,
  ADDTOPO = 3,
  DELTOPO = 4,
  UPPARA = 5
};
bool AppStatus_IsValid(int value);
const AppStatus AppStatus_MIN = SUBMIT;
const AppStatus AppStatus_MAX = UPPARA;
const int AppStatus_ARRAYSIZE = AppStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppStatus_descriptor();
inline const ::std::string& AppStatus_Name(AppStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppStatus_descriptor(), value);
}
inline bool AppStatus_Parse(
    const ::std::string& name, AppStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppStatus>(
    AppStatus_descriptor(), name, value);
}
enum PEStatus {
  CREATE = 0,
  SCHEDULE = 1,
  RUNNING = 2,
  DEL = 3
};
bool PEStatus_IsValid(int value);
const PEStatus PEStatus_MIN = CREATE;
const PEStatus PEStatus_MAX = DEL;
const int PEStatus_ARRAYSIZE = PEStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PEStatus_descriptor();
inline const ::std::string& PEStatus_Name(PEStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PEStatus_descriptor(), value);
}
inline bool PEStatus_Parse(
    const ::std::string& name, PEStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PEStatus>(
    PEStatus_descriptor(), name, value);
}
// ===================================================================

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();
  
  User(const User& from);
  
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();
  
  void Swap(User* other);
  
  // implements Message ----------------------------------------------
  
  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  
  // optional string hostip = 5;
  inline bool has_hostip() const;
  inline void clear_hostip();
  static const int kHostipFieldNumber = 5;
  inline const ::std::string& hostip() const;
  inline void set_hostip(const ::std::string& value);
  inline void set_hostip(const char* value);
  inline void set_hostip(const char* value, size_t size);
  inline ::std::string* mutable_hostip();
  inline ::std::string* release_hostip();
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:dstream.User)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_hostip();
  inline void clear_has_hostip();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* hostname_;
  ::std::string* hostip_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class AppID : public ::google::protobuf::Message {
 public:
  AppID();
  virtual ~AppID();
  
  AppID(const AppID& from);
  
  inline AppID& operator=(const AppID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppID& default_instance();
  
  void Swap(AppID* other);
  
  // implements Message ----------------------------------------------
  
  AppID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppID& from);
  void MergeFrom(const AppID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional fixed64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:dstream.AppID)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static AppID* default_instance_;
};
// -------------------------------------------------------------------

class FileConfig : public ::google::protobuf::Message {
 public:
  FileConfig();
  virtual ~FileConfig();
  
  FileConfig(const FileConfig& from);
  
  inline FileConfig& operator=(const FileConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileConfig& default_instance();
  
  void Swap(FileConfig* other);
  
  // implements Message ----------------------------------------------
  
  FileConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileConfig& from);
  void MergeFrom(const FileConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:dstream.FileConfig)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::std::string* username_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static FileConfig* default_instance_;
};
// -------------------------------------------------------------------

class Processor : public ::google::protobuf::Message {
 public:
  Processor();
  virtual ~Processor();
  
  Processor(const Processor& from);
  
  inline Processor& operator=(const Processor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Processor& default_instance();
  
  void Swap(Processor* other);
  
  // implements Message ----------------------------------------------
  
  Processor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Processor& from);
  void MergeFrom(const Processor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string descr = 2;
  inline bool has_descr() const;
  inline void clear_descr();
  static const int kDescrFieldNumber = 2;
  inline const ::std::string& descr() const;
  inline void set_descr(const ::std::string& value);
  inline void set_descr(const char* value);
  inline void set_descr(const char* value, size_t size);
  inline ::std::string* mutable_descr();
  inline ::std::string* release_descr();
  
  // optional .dstream.ProcessorID id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::dstream::ProcessorID& id() const;
  inline ::dstream::ProcessorID* mutable_id();
  inline ::dstream::ProcessorID* release_id();
  
  // optional .dstream.ProcessorRole role = 4;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 4;
  inline dstream::ProcessorRole role() const;
  inline void set_role(dstream::ProcessorRole value);
  
  // optional string exec_cmd = 5;
  inline bool has_exec_cmd() const;
  inline void clear_exec_cmd();
  static const int kExecCmdFieldNumber = 5;
  inline const ::std::string& exec_cmd() const;
  inline void set_exec_cmd(const ::std::string& value);
  inline void set_exec_cmd(const char* value);
  inline void set_exec_cmd(const char* value, size_t size);
  inline ::std::string* mutable_exec_cmd();
  inline ::std::string* release_exec_cmd();
  
  // optional .dstream.Resource resource_require = 7;
  inline bool has_resource_require() const;
  inline void clear_resource_require();
  static const int kResourceRequireFieldNumber = 7;
  inline const ::dstream::Resource& resource_require() const;
  inline ::dstream::Resource* mutable_resource_require();
  inline ::dstream::Resource* release_resource_require();
  
  // optional fixed32 parallism = 8;
  inline bool has_parallism() const;
  inline void clear_parallism();
  static const int kParallismFieldNumber = 8;
  inline ::google::protobuf::uint32 parallism() const;
  inline void set_parallism(::google::protobuf::uint32 value);
  
  // optional fixed32 backup_num = 9;
  inline bool has_backup_num() const;
  inline void clear_backup_num();
  static const int kBackupNumFieldNumber = 9;
  inline ::google::protobuf::uint32 backup_num() const;
  inline void set_backup_num(::google::protobuf::uint32 value);
  
  // optional .dstream.Publish publish = 10;
  inline bool has_publish() const;
  inline void clear_publish();
  static const int kPublishFieldNumber = 10;
  inline const ::dstream::Publish& publish() const;
  inline ::dstream::Publish* mutable_publish();
  inline ::dstream::Publish* release_publish();
  
  // optional .dstream.Subscribe subscribe = 11;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 11;
  inline const ::dstream::Subscribe& subscribe() const;
  inline ::dstream::Subscribe* mutable_subscribe();
  inline ::dstream::Subscribe* release_subscribe();
  
  // optional string status_mark = 12;
  inline bool has_status_mark() const;
  inline void clear_status_mark();
  static const int kStatusMarkFieldNumber = 12;
  inline const ::std::string& status_mark() const;
  inline void set_status_mark(const ::std::string& value);
  inline void set_status_mark(const char* value);
  inline void set_status_mark(const char* value, size_t size);
  inline ::std::string* mutable_status_mark();
  inline ::std::string* release_status_mark();
  
  // optional fixed64 tuple_batch_count = 13;
  inline bool has_tuple_batch_count() const;
  inline void clear_tuple_batch_count();
  static const int kTupleBatchCountFieldNumber = 13;
  inline ::google::protobuf::uint64 tuple_batch_count() const;
  inline void set_tuple_batch_count(::google::protobuf::uint64 value);
  
  // optional fixed64 force_forward_tuples_period_ms = 14;
  inline bool has_force_forward_tuples_period_ms() const;
  inline void clear_force_forward_tuples_period_ms();
  static const int kForceForwardTuplesPeriodMsFieldNumber = 14;
  inline ::google::protobuf::uint64 force_forward_tuples_period_ms() const;
  inline void set_force_forward_tuples_period_ms(::google::protobuf::uint64 value);
  
  // optional string dynamic_proto_dir = 15;
  inline bool has_dynamic_proto_dir() const;
  inline void clear_dynamic_proto_dir();
  static const int kDynamicProtoDirFieldNumber = 15;
  inline const ::std::string& dynamic_proto_dir() const;
  inline void set_dynamic_proto_dir(const ::std::string& value);
  inline void set_dynamic_proto_dir(const char* value);
  inline void set_dynamic_proto_dir(const char* value, size_t size);
  inline ::std::string* mutable_dynamic_proto_dir();
  inline ::std::string* release_dynamic_proto_dir();
  
  // optional fixed64 send_queue_size = 16;
  inline bool has_send_queue_size() const;
  inline void clear_send_queue_size();
  static const int kSendQueueSizeFieldNumber = 16;
  inline ::google::protobuf::uint64 send_queue_size() const;
  inline void set_send_queue_size(::google::protobuf::uint64 value);
  
  // optional fixed64 recv_queue_size = 17;
  inline bool has_recv_queue_size() const;
  inline void clear_recv_queue_size();
  static const int kRecvQueueSizeFieldNumber = 17;
  inline ::google::protobuf::uint64 recv_queue_size() const;
  inline void set_recv_queue_size(::google::protobuf::uint64 value);
  
  // optional float send_watermark = 18;
  inline bool has_send_watermark() const;
  inline void clear_send_watermark();
  static const int kSendWatermarkFieldNumber = 18;
  inline float send_watermark() const;
  inline void set_send_watermark(float value);
  
  // optional float recv_watermark = 19;
  inline bool has_recv_watermark() const;
  inline void clear_recv_watermark();
  static const int kRecvWatermarkFieldNumber = 19;
  inline float recv_watermark() const;
  inline void set_recv_watermark(float value);
  
  // optional fixed64 fetch_timeout_ms = 20;
  inline bool has_fetch_timeout_ms() const;
  inline void clear_fetch_timeout_ms();
  static const int kFetchTimeoutMsFieldNumber = 20;
  inline ::google::protobuf::uint64 fetch_timeout_ms() const;
  inline void set_fetch_timeout_ms(::google::protobuf::uint64 value);
  
  // optional fixed64 send_timeout_ms = 21;
  inline bool has_send_timeout_ms() const;
  inline void clear_send_timeout_ms();
  static const int kSendTimeoutMsFieldNumber = 21;
  inline ::google::protobuf::uint64 send_timeout_ms() const;
  inline void set_send_timeout_ms(::google::protobuf::uint64 value);
  
  // optional fixed32 exec_workers = 22;
  inline bool has_exec_workers() const;
  inline void clear_exec_workers();
  static const int kExecWorkersFieldNumber = 22;
  inline ::google::protobuf::uint32 exec_workers() const;
  inline void set_exec_workers(::google::protobuf::uint32 value);
  
  // optional fixed32 net_workers = 23;
  inline bool has_net_workers() const;
  inline void clear_net_workers();
  static const int kNetWorkersFieldNumber = 23;
  inline ::google::protobuf::uint32 net_workers() const;
  inline void set_net_workers(::google::protobuf::uint32 value);
  
  // optional fixed32 disk_workers = 24;
  inline bool has_disk_workers() const;
  inline void clear_disk_workers();
  static const int kDiskWorkersFieldNumber = 24;
  inline ::google::protobuf::uint32 disk_workers() const;
  inline void set_disk_workers(::google::protobuf::uint32 value);
  
  // optional fixed64 small_tran_buf_num = 25;
  inline bool has_small_tran_buf_num() const;
  inline void clear_small_tran_buf_num();
  static const int kSmallTranBufNumFieldNumber = 25;
  inline ::google::protobuf::uint64 small_tran_buf_num() const;
  inline void set_small_tran_buf_num(::google::protobuf::uint64 value);
  
  // optional fixed64 small_tran_buf_size = 26;
  inline bool has_small_tran_buf_size() const;
  inline void clear_small_tran_buf_size();
  static const int kSmallTranBufSizeFieldNumber = 26;
  inline ::google::protobuf::uint64 small_tran_buf_size() const;
  inline void set_small_tran_buf_size(::google::protobuf::uint64 value);
  
  // optional fixed64 big_tran_buf_num = 27;
  inline bool has_big_tran_buf_num() const;
  inline void clear_big_tran_buf_num();
  static const int kBigTranBufNumFieldNumber = 27;
  inline ::google::protobuf::uint64 big_tran_buf_num() const;
  inline void set_big_tran_buf_num(::google::protobuf::uint64 value);
  
  // optional float buf_low_mark = 28;
  inline bool has_buf_low_mark() const;
  inline void clear_buf_low_mark();
  static const int kBufLowMarkFieldNumber = 28;
  inline float buf_low_mark() const;
  inline void set_buf_low_mark(float value);
  
  // optional fixed64 tuple_batch_size = 29;
  inline bool has_tuple_batch_size() const;
  inline void clear_tuple_batch_size();
  static const int kTupleBatchSizeFieldNumber = 29;
  inline ::google::protobuf::uint64 tuple_batch_size() const;
  inline void set_tuple_batch_size(::google::protobuf::uint64 value);
  
  // optional string pn_group = 30;
  inline bool has_pn_group() const;
  inline void clear_pn_group();
  static const int kPnGroupFieldNumber = 30;
  inline const ::std::string& pn_group() const;
  inline void set_pn_group(const ::std::string& value);
  inline void set_pn_group(const char* value);
  inline void set_pn_group(const char* value, size_t size);
  inline ::std::string* mutable_pn_group();
  inline ::std::string* release_pn_group();
  
  // optional string persist_progress = 31;
  inline bool has_persist_progress() const;
  inline void clear_persist_progress();
  static const int kPersistProgressFieldNumber = 31;
  inline const ::std::string& persist_progress() const;
  inline void set_persist_progress(const ::std::string& value);
  inline void set_persist_progress(const char* value);
  inline void set_persist_progress(const char* value, size_t size);
  inline ::std::string* mutable_persist_progress();
  inline ::std::string* release_persist_progress();
  
  // optional uint32 cur_revision = 32;
  inline bool has_cur_revision() const;
  inline void clear_cur_revision();
  static const int kCurRevisionFieldNumber = 32;
  inline ::google::protobuf::uint32 cur_revision() const;
  inline void set_cur_revision(::google::protobuf::uint32 value);
  
  // optional uint32 max_revision = 33;
  inline bool has_max_revision() const;
  inline void clear_max_revision();
  static const int kMaxRevisionFieldNumber = 33;
  inline ::google::protobuf::uint32 max_revision() const;
  inline void set_max_revision(::google::protobuf::uint32 value);
  
  // optional .dstream.FlowControl flow_control = 34;
  inline bool has_flow_control() const;
  inline void clear_flow_control();
  static const int kFlowControlFieldNumber = 34;
  inline const ::dstream::FlowControl& flow_control() const;
  inline ::dstream::FlowControl* mutable_flow_control();
  inline ::dstream::FlowControl* release_flow_control();
  
  // @@protoc_insertion_point(class_scope:dstream.Processor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_descr();
  inline void clear_has_descr();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_exec_cmd();
  inline void clear_has_exec_cmd();
  inline void set_has_resource_require();
  inline void clear_has_resource_require();
  inline void set_has_parallism();
  inline void clear_has_parallism();
  inline void set_has_backup_num();
  inline void clear_has_backup_num();
  inline void set_has_publish();
  inline void clear_has_publish();
  inline void set_has_subscribe();
  inline void clear_has_subscribe();
  inline void set_has_status_mark();
  inline void clear_has_status_mark();
  inline void set_has_tuple_batch_count();
  inline void clear_has_tuple_batch_count();
  inline void set_has_force_forward_tuples_period_ms();
  inline void clear_has_force_forward_tuples_period_ms();
  inline void set_has_dynamic_proto_dir();
  inline void clear_has_dynamic_proto_dir();
  inline void set_has_send_queue_size();
  inline void clear_has_send_queue_size();
  inline void set_has_recv_queue_size();
  inline void clear_has_recv_queue_size();
  inline void set_has_send_watermark();
  inline void clear_has_send_watermark();
  inline void set_has_recv_watermark();
  inline void clear_has_recv_watermark();
  inline void set_has_fetch_timeout_ms();
  inline void clear_has_fetch_timeout_ms();
  inline void set_has_send_timeout_ms();
  inline void clear_has_send_timeout_ms();
  inline void set_has_exec_workers();
  inline void clear_has_exec_workers();
  inline void set_has_net_workers();
  inline void clear_has_net_workers();
  inline void set_has_disk_workers();
  inline void clear_has_disk_workers();
  inline void set_has_small_tran_buf_num();
  inline void clear_has_small_tran_buf_num();
  inline void set_has_small_tran_buf_size();
  inline void clear_has_small_tran_buf_size();
  inline void set_has_big_tran_buf_num();
  inline void clear_has_big_tran_buf_num();
  inline void set_has_buf_low_mark();
  inline void clear_has_buf_low_mark();
  inline void set_has_tuple_batch_size();
  inline void clear_has_tuple_batch_size();
  inline void set_has_pn_group();
  inline void clear_has_pn_group();
  inline void set_has_persist_progress();
  inline void clear_has_persist_progress();
  inline void set_has_cur_revision();
  inline void clear_has_cur_revision();
  inline void set_has_max_revision();
  inline void clear_has_max_revision();
  inline void set_has_flow_control();
  inline void clear_has_flow_control();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* descr_;
  ::dstream::ProcessorID* id_;
  ::std::string* exec_cmd_;
  int role_;
  ::google::protobuf::uint32 parallism_;
  ::dstream::Resource* resource_require_;
  ::dstream::Publish* publish_;
  ::dstream::Subscribe* subscribe_;
  ::std::string* status_mark_;
  ::google::protobuf::uint64 tuple_batch_count_;
  ::google::protobuf::uint32 backup_num_;
  float send_watermark_;
  ::google::protobuf::uint64 force_forward_tuples_period_ms_;
  ::std::string* dynamic_proto_dir_;
  ::google::protobuf::uint64 send_queue_size_;
  ::google::protobuf::uint64 recv_queue_size_;
  ::google::protobuf::uint64 fetch_timeout_ms_;
  float recv_watermark_;
  ::google::protobuf::uint32 exec_workers_;
  ::google::protobuf::uint64 send_timeout_ms_;
  ::google::protobuf::uint32 net_workers_;
  ::google::protobuf::uint32 disk_workers_;
  ::google::protobuf::uint64 small_tran_buf_num_;
  ::google::protobuf::uint64 small_tran_buf_size_;
  ::google::protobuf::uint64 big_tran_buf_num_;
  ::google::protobuf::uint64 tuple_batch_size_;
  ::std::string* pn_group_;
  float buf_low_mark_;
  ::google::protobuf::uint32 cur_revision_;
  ::std::string* persist_progress_;
  ::dstream::FlowControl* flow_control_;
  ::google::protobuf::uint32 max_revision_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static Processor* default_instance_;
};
// -------------------------------------------------------------------

class Publish : public ::google::protobuf::Message {
 public:
  Publish();
  virtual ~Publish();
  
  Publish(const Publish& from);
  
  inline Publish& operator=(const Publish& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Publish& default_instance();
  
  void Swap(Publish* other);
  
  // implements Message ----------------------------------------------
  
  Publish* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Publish& from);
  void MergeFrom(const Publish& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string tags = 1;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 1;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();
  
  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // optional .dstream.BigpipePub bigpipe = 3;
  inline bool has_bigpipe() const;
  inline void clear_bigpipe();
  static const int kBigpipeFieldNumber = 3;
  inline const ::dstream::BigpipePub& bigpipe() const;
  inline ::dstream::BigpipePub* mutable_bigpipe();
  inline ::dstream::BigpipePub* release_bigpipe();
  
  // @@protoc_insertion_point(class_scope:dstream.Publish)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bigpipe();
  inline void clear_has_bigpipe();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::std::string* type_;
  ::dstream::BigpipePub* bigpipe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static Publish* default_instance_;
};
// -------------------------------------------------------------------

class BigpipePub : public ::google::protobuf::Message {
 public:
  BigpipePub();
  virtual ~BigpipePub();
  
  BigpipePub(const BigpipePub& from);
  
  inline BigpipePub& operator=(const BigpipePub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigpipePub& default_instance();
  
  void Swap(BigpipePub* other);
  
  // implements Message ----------------------------------------------
  
  BigpipePub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigpipePub& from);
  void MergeFrom(const BigpipePub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string pipe_name = 1;
  inline bool has_pipe_name() const;
  inline void clear_pipe_name();
  static const int kPipeNameFieldNumber = 1;
  inline const ::std::string& pipe_name() const;
  inline void set_pipe_name(const ::std::string& value);
  inline void set_pipe_name(const char* value);
  inline void set_pipe_name(const char* value, size_t size);
  inline ::std::string* mutable_pipe_name();
  inline ::std::string* release_pipe_name();
  
  // optional string pub_token = 2;
  inline bool has_pub_token() const;
  inline void clear_pub_token();
  static const int kPubTokenFieldNumber = 2;
  inline const ::std::string& pub_token() const;
  inline void set_pub_token(const ::std::string& value);
  inline void set_pub_token(const char* value);
  inline void set_pub_token(const char* value, size_t size);
  inline ::std::string* mutable_pub_token();
  inline ::std::string* release_pub_token();
  
  // optional fixed32 pipelet_num = 3;
  inline bool has_pipelet_num() const;
  inline void clear_pipelet_num();
  static const int kPipeletNumFieldNumber = 3;
  inline ::google::protobuf::uint32 pipelet_num() const;
  inline void set_pipelet_num(::google::protobuf::uint32 value);
  
  // optional fixed32 retry_time = 4;
  inline bool has_retry_time() const;
  inline void clear_retry_time();
  static const int kRetryTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 retry_time() const;
  inline void set_retry_time(::google::protobuf::uint32 value);
  
  // optional fixed32 retry_interval = 5;
  inline bool has_retry_interval() const;
  inline void clear_retry_interval();
  static const int kRetryIntervalFieldNumber = 5;
  inline ::google::protobuf::uint32 retry_interval() const;
  inline void set_retry_interval(::google::protobuf::uint32 value);
  
  // optional string pub_user = 6;
  inline bool has_pub_user() const;
  inline void clear_pub_user();
  static const int kPubUserFieldNumber = 6;
  inline const ::std::string& pub_user() const;
  inline void set_pub_user(const ::std::string& value);
  inline void set_pub_user(const char* value);
  inline void set_pub_user(const char* value, size_t size);
  inline ::std::string* mutable_pub_user();
  inline ::std::string* release_pub_user();
  
  // @@protoc_insertion_point(class_scope:dstream.BigpipePub)
 private:
  inline void set_has_pipe_name();
  inline void clear_has_pipe_name();
  inline void set_has_pub_token();
  inline void clear_has_pub_token();
  inline void set_has_pipelet_num();
  inline void clear_has_pipelet_num();
  inline void set_has_retry_time();
  inline void clear_has_retry_time();
  inline void set_has_retry_interval();
  inline void clear_has_retry_interval();
  inline void set_has_pub_user();
  inline void clear_has_pub_user();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pipe_name_;
  ::std::string* pub_token_;
  ::google::protobuf::uint32 pipelet_num_;
  ::google::protobuf::uint32 retry_time_;
  ::std::string* pub_user_;
  ::google::protobuf::uint32 retry_interval_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static BigpipePub* default_instance_;
};
// -------------------------------------------------------------------

class Subscribe : public ::google::protobuf::Message {
 public:
  Subscribe();
  virtual ~Subscribe();
  
  Subscribe(const Subscribe& from);
  
  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Subscribe& default_instance();
  
  void Swap(Subscribe* other);
  
  // implements Message ----------------------------------------------
  
  Subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Subscribe& from);
  void MergeFrom(const Subscribe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.BigpipeSub bigpipe = 1;
  inline int bigpipe_size() const;
  inline void clear_bigpipe();
  static const int kBigpipeFieldNumber = 1;
  inline const ::dstream::BigpipeSub& bigpipe(int index) const;
  inline ::dstream::BigpipeSub* mutable_bigpipe(int index);
  inline ::dstream::BigpipeSub* add_bigpipe();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::BigpipeSub >&
      bigpipe() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::BigpipeSub >*
      mutable_bigpipe();
  
  // repeated .dstream.HdfsSub hdfs = 2;
  inline int hdfs_size() const;
  inline void clear_hdfs();
  static const int kHdfsFieldNumber = 2;
  inline const ::dstream::HdfsSub& hdfs(int index) const;
  inline ::dstream::HdfsSub* mutable_hdfs(int index);
  inline ::dstream::HdfsSub* add_hdfs();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::HdfsSub >&
      hdfs() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::HdfsSub >*
      mutable_hdfs();
  
  // repeated .dstream.ProcessorSub processor = 3;
  inline int processor_size() const;
  inline void clear_processor();
  static const int kProcessorFieldNumber = 3;
  inline const ::dstream::ProcessorSub& processor(int index) const;
  inline ::dstream::ProcessorSub* mutable_processor(int index);
  inline ::dstream::ProcessorSub* add_processor();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorSub >&
      processor() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorSub >*
      mutable_processor();
  
  // repeated .dstream.LocalSub localfile = 4;
  inline int localfile_size() const;
  inline void clear_localfile();
  static const int kLocalfileFieldNumber = 4;
  inline const ::dstream::LocalSub& localfile(int index) const;
  inline ::dstream::LocalSub* mutable_localfile(int index);
  inline ::dstream::LocalSub* add_localfile();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::LocalSub >&
      localfile() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::LocalSub >*
      mutable_localfile();
  
  // repeated .dstream.ScribeSub scribe = 5;
  inline int scribe_size() const;
  inline void clear_scribe();
  static const int kScribeFieldNumber = 5;
  inline const ::dstream::ScribeSub& scribe(int index) const;
  inline ::dstream::ScribeSub* mutable_scribe(int index);
  inline ::dstream::ScribeSub* add_scribe();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::ScribeSub >&
      scribe() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::ScribeSub >*
      mutable_scribe();
  
  // repeated .dstream.FakeSub fake = 6;
  inline int fake_size() const;
  inline void clear_fake();
  static const int kFakeFieldNumber = 6;
  inline const ::dstream::FakeSub& fake(int index) const;
  inline ::dstream::FakeSub* mutable_fake(int index);
  inline ::dstream::FakeSub* add_fake();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::FakeSub >&
      fake() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::FakeSub >*
      mutable_fake();
  
  // @@protoc_insertion_point(class_scope:dstream.Subscribe)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::BigpipeSub > bigpipe_;
  ::google::protobuf::RepeatedPtrField< ::dstream::HdfsSub > hdfs_;
  ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorSub > processor_;
  ::google::protobuf::RepeatedPtrField< ::dstream::LocalSub > localfile_;
  ::google::protobuf::RepeatedPtrField< ::dstream::ScribeSub > scribe_;
  ::google::protobuf::RepeatedPtrField< ::dstream::FakeSub > fake_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static Subscribe* default_instance_;
};
// -------------------------------------------------------------------

class LocalSub : public ::google::protobuf::Message {
 public:
  LocalSub();
  virtual ~LocalSub();
  
  LocalSub(const LocalSub& from);
  
  inline LocalSub& operator=(const LocalSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSub& default_instance();
  
  void Swap(LocalSub* other);
  
  // implements Message ----------------------------------------------
  
  LocalSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalSub& from);
  void MergeFrom(const LocalSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional fixed64 sub_point = 2;
  inline bool has_sub_point() const;
  inline void clear_sub_point();
  static const int kSubPointFieldNumber = 2;
  inline ::google::protobuf::uint64 sub_point() const;
  inline void set_sub_point(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:dstream.LocalSub)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_sub_point();
  inline void clear_has_sub_point();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::google::protobuf::uint64 sub_point_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static LocalSub* default_instance_;
};
// -------------------------------------------------------------------

class ScribeSub : public ::google::protobuf::Message {
 public:
  ScribeSub();
  virtual ~ScribeSub();
  
  ScribeSub(const ScribeSub& from);
  
  inline ScribeSub& operator=(const ScribeSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScribeSub& default_instance();
  
  void Swap(ScribeSub* other);
  
  // implements Message ----------------------------------------------
  
  ScribeSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScribeSub& from);
  void MergeFrom(const ScribeSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed32 buffersize = 1;
  inline bool has_buffersize() const;
  inline void clear_buffersize();
  static const int kBuffersizeFieldNumber = 1;
  inline ::google::protobuf::uint32 buffersize() const;
  inline void set_buffersize(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.ScribeSub)
 private:
  inline void set_has_buffersize();
  inline void clear_has_buffersize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 buffersize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static ScribeSub* default_instance_;
};
// -------------------------------------------------------------------

class BigpipeSub : public ::google::protobuf::Message {
 public:
  BigpipeSub();
  virtual ~BigpipeSub();
  
  BigpipeSub(const BigpipeSub& from);
  
  inline BigpipeSub& operator=(const BigpipeSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigpipeSub& default_instance();
  
  void Swap(BigpipeSub* other);
  
  // implements Message ----------------------------------------------
  
  BigpipeSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigpipeSub& from);
  void MergeFrom(const BigpipeSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string pipelet = 4;
  inline bool has_pipelet() const;
  inline void clear_pipelet();
  static const int kPipeletFieldNumber = 4;
  inline const ::std::string& pipelet() const;
  inline void set_pipelet(const ::std::string& value);
  inline void set_pipelet(const char* value);
  inline void set_pipelet(const char* value, size_t size);
  inline ::std::string* mutable_pipelet();
  inline ::std::string* release_pipelet();
  
  // optional fixed32 pipelet_num = 5;
  inline bool has_pipelet_num() const;
  inline void clear_pipelet_num();
  static const int kPipeletNumFieldNumber = 5;
  inline ::google::protobuf::uint32 pipelet_num() const;
  inline void set_pipelet_num(::google::protobuf::uint32 value);
  
  // repeated fixed32 pipelet_id = 6;
  inline int pipelet_id_size() const;
  inline void clear_pipelet_id();
  static const int kPipeletIdFieldNumber = 6;
  inline ::google::protobuf::uint32 pipelet_id(int index) const;
  inline void set_pipelet_id(int index, ::google::protobuf::uint32 value);
  inline void add_pipelet_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pipelet_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pipelet_id();
  
  // optional fixed64 sub_point = 7;
  inline bool has_sub_point() const;
  inline void clear_sub_point();
  static const int kSubPointFieldNumber = 7;
  inline ::google::protobuf::uint64 sub_point() const;
  inline void set_sub_point(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:dstream.BigpipeSub)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_pipelet();
  inline void clear_has_pipelet();
  inline void set_has_pipelet_num();
  inline void clear_has_pipelet_num();
  inline void set_has_sub_point();
  inline void clear_has_sub_point();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* pipelet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pipelet_id_;
  ::google::protobuf::uint64 sub_point_;
  ::google::protobuf::uint32 pipelet_num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static BigpipeSub* default_instance_;
};
// -------------------------------------------------------------------

class HdfsSub : public ::google::protobuf::Message {
 public:
  HdfsSub();
  virtual ~HdfsSub();
  
  HdfsSub(const HdfsSub& from);
  
  inline HdfsSub& operator=(const HdfsSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HdfsSub& default_instance();
  
  void Swap(HdfsSub* other);
  
  // implements Message ----------------------------------------------
  
  HdfsSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HdfsSub& from);
  void MergeFrom(const HdfsSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:dstream.HdfsSub)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::std::string* username_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static HdfsSub* default_instance_;
};
// -------------------------------------------------------------------

class ProcessorSub : public ::google::protobuf::Message {
 public:
  ProcessorSub();
  virtual ~ProcessorSub();
  
  ProcessorSub(const ProcessorSub& from);
  
  inline ProcessorSub& operator=(const ProcessorSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorSub& default_instance();
  
  void Swap(ProcessorSub* other);
  
  // implements Message ----------------------------------------------
  
  ProcessorSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessorSub& from);
  void MergeFrom(const ProcessorSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string tags = 2;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 2;
  inline const ::std::string& tags() const;
  inline void set_tags(const ::std::string& value);
  inline void set_tags(const char* value);
  inline void set_tags(const char* value, size_t size);
  inline ::std::string* mutable_tags();
  inline ::std::string* release_tags();
  
  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:dstream.ProcessorSub)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tags();
  inline void clear_has_tags();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* tags_;
  ::std::string* username_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static ProcessorSub* default_instance_;
};
// -------------------------------------------------------------------

class FakeSub : public ::google::protobuf::Message {
 public:
  FakeSub();
  virtual ~FakeSub();
  
  FakeSub(const FakeSub& from);
  
  inline FakeSub& operator=(const FakeSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FakeSub& default_instance();
  
  void Swap(FakeSub* other);
  
  // implements Message ----------------------------------------------
  
  FakeSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FakeSub& from);
  void MergeFrom(const FakeSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:dstream.FakeSub)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static FakeSub* default_instance_;
};
// -------------------------------------------------------------------

class Topology : public ::google::protobuf::Message {
 public:
  Topology();
  virtual ~Topology();
  
  Topology(const Topology& from);
  
  inline Topology& operator=(const Topology& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Topology& default_instance();
  
  void Swap(Topology* other);
  
  // implements Message ----------------------------------------------
  
  Topology* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Topology& from);
  void MergeFrom(const Topology& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed32 processor_num = 1;
  inline bool has_processor_num() const;
  inline void clear_processor_num();
  static const int kProcessorNumFieldNumber = 1;
  inline ::google::protobuf::uint32 processor_num() const;
  inline void set_processor_num(::google::protobuf::uint32 value);
  
  // repeated .dstream.Processor processors = 2;
  inline int processors_size() const;
  inline void clear_processors();
  static const int kProcessorsFieldNumber = 2;
  inline const ::dstream::Processor& processors(int index) const;
  inline ::dstream::Processor* mutable_processors(int index);
  inline ::dstream::Processor* add_processors();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::Processor >&
      processors() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::Processor >*
      mutable_processors();
  
  // repeated .dstream.ProcessorID importer_id = 3;
  inline int importer_id_size() const;
  inline void clear_importer_id();
  static const int kImporterIdFieldNumber = 3;
  inline const ::dstream::ProcessorID& importer_id(int index) const;
  inline ::dstream::ProcessorID* mutable_importer_id(int index);
  inline ::dstream::ProcessorID* add_importer_id();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >&
      importer_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >*
      mutable_importer_id();
  
  // repeated .dstream.ProcessorID exporter_id = 4;
  inline int exporter_id_size() const;
  inline void clear_exporter_id();
  static const int kExporterIdFieldNumber = 4;
  inline const ::dstream::ProcessorID& exporter_id(int index) const;
  inline ::dstream::ProcessorID* mutable_exporter_id(int index);
  inline ::dstream::ProcessorID* add_exporter_id();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >&
      exporter_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >*
      mutable_exporter_id();
  
  // optional fixed32 upstream_bigpipe_num = 5;
  inline bool has_upstream_bigpipe_num() const;
  inline void clear_upstream_bigpipe_num();
  static const int kUpstreamBigpipeNumFieldNumber = 5;
  inline ::google::protobuf::uint32 upstream_bigpipe_num() const;
  inline void set_upstream_bigpipe_num(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.Topology)
 private:
  inline void set_has_processor_num();
  inline void clear_has_processor_num();
  inline void set_has_upstream_bigpipe_num();
  inline void clear_has_upstream_bigpipe_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::Processor > processors_;
  ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID > importer_id_;
  ::google::protobuf::uint32 processor_num_;
  ::google::protobuf::uint32 upstream_bigpipe_num_;
  ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID > exporter_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static Topology* default_instance_;
};
// -------------------------------------------------------------------

class FlowControl : public ::google::protobuf::Message {
 public:
  FlowControl();
  virtual ~FlowControl();
  
  FlowControl(const FlowControl& from);
  
  inline FlowControl& operator=(const FlowControl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowControl& default_instance();
  
  void Swap(FlowControl* other);
  
  // implements Message ----------------------------------------------
  
  FlowControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowControl& from);
  void MergeFrom(const FlowControl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 qps_limit = 1 [default = -1];
  inline bool has_qps_limit() const;
  inline void clear_qps_limit();
  static const int kQpsLimitFieldNumber = 1;
  inline ::google::protobuf::int32 qps_limit() const;
  inline void set_qps_limit(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.FlowControl)
 private:
  inline void set_has_qps_limit();
  inline void clear_has_qps_limit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 qps_limit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static FlowControl* default_instance_;
};
// -------------------------------------------------------------------

class Application : public ::google::protobuf::Message {
 public:
  Application();
  virtual ~Application();
  
  Application(const Application& from);
  
  inline Application& operator=(const Application& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Application& default_instance();
  
  void Swap(Application* other);
  
  // implements Message ----------------------------------------------
  
  Application* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Application& from);
  void MergeFrom(const Application& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional .dstream.AppID id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::dstream::AppID& id() const;
  inline ::dstream::AppID* mutable_id();
  inline ::dstream::AppID* release_id();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string descr = 4;
  inline bool has_descr() const;
  inline void clear_descr();
  static const int kDescrFieldNumber = 4;
  inline const ::std::string& descr() const;
  inline void set_descr(const ::std::string& value);
  inline void set_descr(const char* value);
  inline void set_descr(const char* value, size_t size);
  inline ::std::string* mutable_descr();
  inline ::std::string* release_descr();
  
  // optional .dstream.User user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::dstream::User& user() const;
  inline ::dstream::User* mutable_user();
  inline ::dstream::User* release_user();
  
  // optional .dstream.FileConfig app_path = 6;
  inline bool has_app_path() const;
  inline void clear_app_path();
  static const int kAppPathFieldNumber = 6;
  inline const ::dstream::FileConfig& app_path() const;
  inline ::dstream::FileConfig* mutable_app_path();
  inline ::dstream::FileConfig* release_app_path();
  
  // optional .dstream.FileConfig checkpoint_path = 7;
  inline bool has_checkpoint_path() const;
  inline void clear_checkpoint_path();
  static const int kCheckpointPathFieldNumber = 7;
  inline const ::dstream::FileConfig& checkpoint_path() const;
  inline ::dstream::FileConfig* mutable_checkpoint_path();
  inline ::dstream::FileConfig* release_checkpoint_path();
  
  // optional .dstream.BigpipeSub bigpipe = 8;
  inline bool has_bigpipe() const;
  inline void clear_bigpipe();
  static const int kBigpipeFieldNumber = 8;
  inline const ::dstream::BigpipeSub& bigpipe() const;
  inline ::dstream::BigpipeSub* mutable_bigpipe();
  inline ::dstream::BigpipeSub* release_bigpipe();
  
  // optional .dstream.Topology topology = 9;
  inline bool has_topology() const;
  inline void clear_topology();
  static const int kTopologyFieldNumber = 9;
  inline const ::dstream::Topology& topology() const;
  inline ::dstream::Topology* mutable_topology();
  inline ::dstream::Topology* release_topology();
  
  // optional .dstream.AppStatus status = 10;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 10;
  inline dstream::AppStatus status() const;
  inline void set_status(dstream::AppStatus value);
  
  // optional .dstream.FileConfig log_path = 11;
  inline bool has_log_path() const;
  inline void clear_log_path();
  static const int kLogPathFieldNumber = 11;
  inline const ::dstream::FileConfig& log_path() const;
  inline ::dstream::FileConfig* mutable_log_path();
  inline ::dstream::FileConfig* release_log_path();
  
  // optional fixed64 submit_time = 12;
  inline bool has_submit_time() const;
  inline void clear_submit_time();
  static const int kSubmitTimeFieldNumber = 12;
  inline ::google::protobuf::uint64 submit_time() const;
  inline void set_submit_time(::google::protobuf::uint64 value);
  
  // optional fixed32 data_strategy = 14;
  inline bool has_data_strategy() const;
  inline void clear_data_strategy();
  static const int kDataStrategyFieldNumber = 14;
  inline ::google::protobuf::uint32 data_strategy() const;
  inline void set_data_strategy(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.Application)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_descr();
  inline void clear_has_descr();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_app_path();
  inline void clear_has_app_path();
  inline void set_has_checkpoint_path();
  inline void clear_has_checkpoint_path();
  inline void set_has_bigpipe();
  inline void clear_has_bigpipe();
  inline void set_has_topology();
  inline void clear_has_topology();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_log_path();
  inline void clear_has_log_path();
  inline void set_has_submit_time();
  inline void clear_has_submit_time();
  inline void set_has_data_strategy();
  inline void clear_has_data_strategy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::dstream::AppID* id_;
  ::std::string* name_;
  ::std::string* descr_;
  ::dstream::User* user_;
  ::dstream::FileConfig* app_path_;
  ::dstream::FileConfig* checkpoint_path_;
  ::dstream::BigpipeSub* bigpipe_;
  ::dstream::Topology* topology_;
  ::dstream::FileConfig* log_path_;
  int status_;
  ::google::protobuf::uint32 data_strategy_;
  ::google::protobuf::uint64 submit_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static Application* default_instance_;
};
// -------------------------------------------------------------------

class BackupPEID : public ::google::protobuf::Message {
 public:
  BackupPEID();
  virtual ~BackupPEID();
  
  BackupPEID(const BackupPEID& from);
  
  inline BackupPEID& operator=(const BackupPEID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupPEID& default_instance();
  
  void Swap(BackupPEID* other);
  
  // implements Message ----------------------------------------------
  
  BackupPEID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackupPEID& from);
  void MergeFrom(const BackupPEID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:dstream.BackupPEID)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static BackupPEID* default_instance_;
};
// -------------------------------------------------------------------

class BackupPE : public ::google::protobuf::Message {
 public:
  BackupPE();
  virtual ~BackupPE();
  
  BackupPE(const BackupPE& from);
  
  inline BackupPE& operator=(const BackupPE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupPE& default_instance();
  
  void Swap(BackupPE* other);
  
  // implements Message ----------------------------------------------
  
  BackupPE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackupPE& from);
  void MergeFrom(const BackupPE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.BackupPEID backup_pe_id = 1;
  inline bool has_backup_pe_id() const;
  inline void clear_backup_pe_id();
  static const int kBackupPeIdFieldNumber = 1;
  inline const ::dstream::BackupPEID& backup_pe_id() const;
  inline ::dstream::BackupPEID* mutable_backup_pe_id();
  inline ::dstream::BackupPEID* release_backup_pe_id();
  
  // optional .dstream.PNID pn_id = 2;
  inline bool has_pn_id() const;
  inline void clear_pn_id();
  static const int kPnIdFieldNumber = 2;
  inline const ::dstream::PNID& pn_id() const;
  inline ::dstream::PNID* mutable_pn_id();
  inline ::dstream::PNID* release_pn_id();
  
  // optional fixed64 last_assignment_time = 3;
  inline bool has_last_assignment_time() const;
  inline void clear_last_assignment_time();
  static const int kLastAssignmentTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 last_assignment_time() const;
  inline void set_last_assignment_time(::google::protobuf::uint64 value);
  
  // optional .dstream.PEStatus pe_status = 4;
  inline bool has_pe_status() const;
  inline void clear_pe_status();
  static const int kPeStatusFieldNumber = 4;
  inline dstream::PEStatus pe_status() const;
  inline void set_pe_status(dstream::PEStatus value);
  
  // optional string last_fail_pn = 5;
  inline bool has_last_fail_pn() const;
  inline void clear_last_fail_pn();
  static const int kLastFailPnFieldNumber = 5;
  inline const ::std::string& last_fail_pn() const;
  inline void set_last_fail_pn(const ::std::string& value);
  inline void set_last_fail_pn(const char* value);
  inline void set_last_fail_pn(const char* value, size_t size);
  inline ::std::string* mutable_last_fail_pn();
  inline ::std::string* release_last_fail_pn();
  
  // optional fixed32 fail_number = 6;
  inline bool has_fail_number() const;
  inline void clear_fail_number();
  static const int kFailNumberFieldNumber = 6;
  inline ::google::protobuf::uint32 fail_number() const;
  inline void set_fail_number(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.BackupPE)
 private:
  inline void set_has_backup_pe_id();
  inline void clear_has_backup_pe_id();
  inline void set_has_pn_id();
  inline void clear_has_pn_id();
  inline void set_has_last_assignment_time();
  inline void clear_has_last_assignment_time();
  inline void set_has_pe_status();
  inline void clear_has_pe_status();
  inline void set_has_last_fail_pn();
  inline void clear_has_last_fail_pn();
  inline void set_has_fail_number();
  inline void clear_has_fail_number();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::BackupPEID* backup_pe_id_;
  ::dstream::PNID* pn_id_;
  ::google::protobuf::uint64 last_assignment_time_;
  ::std::string* last_fail_pn_;
  int pe_status_;
  ::google::protobuf::uint32 fail_number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static BackupPE* default_instance_;
};
// -------------------------------------------------------------------

class logConfig : public ::google::protobuf::Message {
 public:
  logConfig();
  virtual ~logConfig();
  
  logConfig(const logConfig& from);
  
  inline logConfig& operator=(const logConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const logConfig& default_instance();
  
  void Swap(logConfig* other);
  
  // implements Message ----------------------------------------------
  
  logConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const logConfig& from);
  void MergeFrom(const logConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.BigpipeSub bigpipe = 1;
  inline bool has_bigpipe() const;
  inline void clear_bigpipe();
  static const int kBigpipeFieldNumber = 1;
  inline const ::dstream::BigpipeSub& bigpipe() const;
  inline ::dstream::BigpipeSub* mutable_bigpipe();
  inline ::dstream::BigpipeSub* release_bigpipe();
  
  // optional string pipe_name = 2;
  inline bool has_pipe_name() const;
  inline void clear_pipe_name();
  static const int kPipeNameFieldNumber = 2;
  inline const ::std::string& pipe_name() const;
  inline void set_pipe_name(const ::std::string& value);
  inline void set_pipe_name(const char* value);
  inline void set_pipe_name(const char* value, size_t size);
  inline ::std::string* mutable_pipe_name();
  inline ::std::string* release_pipe_name();
  
  // optional fixed32 pipelet = 3;
  inline bool has_pipelet() const;
  inline void clear_pipelet();
  static const int kPipeletFieldNumber = 3;
  inline ::google::protobuf::uint32 pipelet() const;
  inline void set_pipelet(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.logConfig)
 private:
  inline void set_has_bigpipe();
  inline void clear_has_bigpipe();
  inline void set_has_pipe_name();
  inline void clear_has_pipe_name();
  inline void set_has_pipelet();
  inline void clear_has_pipelet();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::BigpipeSub* bigpipe_;
  ::std::string* pipe_name_;
  ::google::protobuf::uint32 pipelet_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static logConfig* default_instance_;
};
// -------------------------------------------------------------------

class ProcessorElement : public ::google::protobuf::Message {
 public:
  ProcessorElement();
  virtual ~ProcessorElement();
  
  ProcessorElement(const ProcessorElement& from);
  
  inline ProcessorElement& operator=(const ProcessorElement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorElement& default_instance();
  
  void Swap(ProcessorElement* other);
  
  // implements Message ----------------------------------------------
  
  ProcessorElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessorElement& from);
  void MergeFrom(const ProcessorElement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.AppID app = 1;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 1;
  inline const ::dstream::AppID& app() const;
  inline ::dstream::AppID* mutable_app();
  inline ::dstream::AppID* release_app();
  
  // optional .dstream.ProcessorID processor = 2;
  inline bool has_processor() const;
  inline void clear_processor();
  static const int kProcessorFieldNumber = 2;
  inline const ::dstream::ProcessorID& processor() const;
  inline ::dstream::ProcessorID* mutable_processor();
  inline ::dstream::ProcessorID* release_processor();
  
  // optional .dstream.PEID pe_id = 3;
  inline bool has_pe_id() const;
  inline void clear_pe_id();
  static const int kPeIdFieldNumber = 3;
  inline const ::dstream::PEID& pe_id() const;
  inline ::dstream::PEID* mutable_pe_id();
  inline ::dstream::PEID* release_pe_id();
  
  // optional fixed64 serial = 4;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 4;
  inline ::google::protobuf::uint64 serial() const;
  inline void set_serial(::google::protobuf::uint64 value);
  
  // optional .dstream.logConfig log = 5;
  inline bool has_log() const;
  inline void clear_log();
  static const int kLogFieldNumber = 5;
  inline const ::dstream::logConfig& log() const;
  inline ::dstream::logConfig* mutable_log();
  inline ::dstream::logConfig* release_log();
  
  // repeated .dstream.BackupPE backups = 6;
  inline int backups_size() const;
  inline void clear_backups();
  static const int kBackupsFieldNumber = 6;
  inline const ::dstream::BackupPE& backups(int index) const;
  inline ::dstream::BackupPE* mutable_backups(int index);
  inline ::dstream::BackupPE* add_backups();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::BackupPE >&
      backups() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::BackupPE >*
      mutable_backups();
  
  // repeated .dstream.BackupPEID primary = 7;
  inline int primary_size() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 7;
  inline const ::dstream::BackupPEID& primary(int index) const;
  inline ::dstream::BackupPEID* mutable_primary(int index);
  inline ::dstream::BackupPEID* add_primary();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEID >&
      primary() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEID >*
      mutable_primary();
  
  // optional string processor_name = 8;
  inline bool has_processor_name() const;
  inline void clear_processor_name();
  static const int kProcessorNameFieldNumber = 8;
  inline const ::std::string& processor_name() const;
  inline void set_processor_name(const ::std::string& value);
  inline void set_processor_name(const char* value);
  inline void set_processor_name(const char* value, size_t size);
  inline ::std::string* mutable_processor_name();
  inline ::std::string* release_processor_name();
  
  // optional .dstream.Resource resource = 9;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 9;
  inline const ::dstream::Resource& resource() const;
  inline ::dstream::Resource* mutable_resource();
  inline ::dstream::Resource* release_resource();
  
  // @@protoc_insertion_point(class_scope:dstream.ProcessorElement)
 private:
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_processor();
  inline void clear_has_processor();
  inline void set_has_pe_id();
  inline void clear_has_pe_id();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_log();
  inline void clear_has_log();
  inline void set_has_processor_name();
  inline void clear_has_processor_name();
  inline void set_has_resource();
  inline void clear_has_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::AppID* app_;
  ::dstream::ProcessorID* processor_;
  ::dstream::PEID* pe_id_;
  ::google::protobuf::uint64 serial_;
  ::dstream::logConfig* log_;
  ::google::protobuf::RepeatedPtrField< ::dstream::BackupPE > backups_;
  ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEID > primary_;
  ::std::string* processor_name_;
  ::dstream::Resource* resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static ProcessorElement* default_instance_;
};
// -------------------------------------------------------------------

class SubPoint : public ::google::protobuf::Message {
 public:
  SubPoint();
  virtual ~SubPoint();
  
  SubPoint(const SubPoint& from);
  
  inline SubPoint& operator=(const SubPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubPoint& default_instance();
  
  void Swap(SubPoint* other);
  
  // implements Message ----------------------------------------------
  
  SubPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubPoint& from);
  void MergeFrom(const SubPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::dstream::PEID& id() const;
  inline ::dstream::PEID* mutable_id();
  inline ::dstream::PEID* release_id();
  
  // optional int64 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::int64 msg_id() const;
  inline void set_msg_id(::google::protobuf::int64 value);
  
  // optional fixed64 seq_id = 3;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  inline ::google::protobuf::uint64 seq_id() const;
  inline void set_seq_id(::google::protobuf::uint64 value);
  
  // optional fixed32 pipelet = 4;
  inline bool has_pipelet() const;
  inline void clear_pipelet();
  static const int kPipeletFieldNumber = 4;
  inline ::google::protobuf::uint32 pipelet() const;
  inline void set_pipelet(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.SubPoint)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_pipelet();
  inline void clear_has_pipelet();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* id_;
  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::uint64 seq_id_;
  ::google::protobuf::uint32 pipelet_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_application_2eproto();
  friend void protobuf_AssignDesc_application_2eproto();
  friend void protobuf_ShutdownFile_application_2eproto();
  
  void InitAsDefaultInstance();
  static SubPoint* default_instance_;
};
// ===================================================================


// ===================================================================

// User

// optional fixed64 session_id = 1;
inline bool User::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 User::session_id() const {
  return session_id_;
}
inline void User::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional string username = 2;
inline bool User::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& User::username() const {
  return *username_;
}
inline void User::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void User::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void User::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* User::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 3;
inline bool User::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& User::password() const {
  return *password_;
}
inline void User::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* User::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string hostname = 4;
inline bool User::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& User::hostname() const {
  return *hostname_;
}
inline void User::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void User::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void User::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* User::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string hostip = 5;
inline bool User::has_hostip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_hostip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_hostip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_hostip() {
  if (hostip_ != &::google::protobuf::internal::kEmptyString) {
    hostip_->clear();
  }
  clear_has_hostip();
}
inline const ::std::string& User::hostip() const {
  return *hostip_;
}
inline void User::set_hostip(const ::std::string& value) {
  set_has_hostip();
  if (hostip_ == &::google::protobuf::internal::kEmptyString) {
    hostip_ = new ::std::string;
  }
  hostip_->assign(value);
}
inline void User::set_hostip(const char* value) {
  set_has_hostip();
  if (hostip_ == &::google::protobuf::internal::kEmptyString) {
    hostip_ = new ::std::string;
  }
  hostip_->assign(value);
}
inline void User::set_hostip(const char* value, size_t size) {
  set_has_hostip();
  if (hostip_ == &::google::protobuf::internal::kEmptyString) {
    hostip_ = new ::std::string;
  }
  hostip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_hostip() {
  set_has_hostip();
  if (hostip_ == &::google::protobuf::internal::kEmptyString) {
    hostip_ = new ::std::string;
  }
  return hostip_;
}
inline ::std::string* User::release_hostip() {
  clear_has_hostip();
  if (hostip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostip_;
    hostip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 6;
inline bool User::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& User::version() const {
  return *version_;
}
inline void User::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void User::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void User::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* User::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AppID

// optional fixed64 session_id = 1;
inline bool AppID::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppID::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppID::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppID::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 AppID::session_id() const {
  return session_id_;
}
inline void AppID::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional fixed64 id = 2;
inline bool AppID::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppID::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppID::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppID::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AppID::id() const {
  return id_;
}
inline void AppID::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// FileConfig

// optional string path = 1;
inline bool FileConfig::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileConfig::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileConfig::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileConfig::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FileConfig::path() const {
  return *path_;
}
inline void FileConfig::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileConfig::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileConfig::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileConfig::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FileConfig::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string username = 2;
inline bool FileConfig::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileConfig::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileConfig::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileConfig::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& FileConfig::username() const {
  return *username_;
}
inline void FileConfig::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FileConfig::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FileConfig::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileConfig::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* FileConfig::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 3;
inline bool FileConfig::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileConfig::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileConfig::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileConfig::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& FileConfig::password() const {
  return *password_;
}
inline void FileConfig::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void FileConfig::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void FileConfig::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileConfig::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* FileConfig::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Processor

// optional string name = 1;
inline bool Processor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Processor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Processor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Processor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Processor::name() const {
  return *name_;
}
inline void Processor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Processor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Processor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Processor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string descr = 2;
inline bool Processor::has_descr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Processor::set_has_descr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Processor::clear_has_descr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Processor::clear_descr() {
  if (descr_ != &::google::protobuf::internal::kEmptyString) {
    descr_->clear();
  }
  clear_has_descr();
}
inline const ::std::string& Processor::descr() const {
  return *descr_;
}
inline void Processor::set_descr(const ::std::string& value) {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  descr_->assign(value);
}
inline void Processor::set_descr(const char* value) {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  descr_->assign(value);
}
inline void Processor::set_descr(const char* value, size_t size) {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  descr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_descr() {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  return descr_;
}
inline ::std::string* Processor::release_descr() {
  clear_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = descr_;
    descr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.ProcessorID id = 3;
inline bool Processor::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Processor::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Processor::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Processor::clear_id() {
  if (id_ != NULL) id_->::dstream::ProcessorID::Clear();
  clear_has_id();
}
inline const ::dstream::ProcessorID& Processor::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::dstream::ProcessorID* Processor::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::dstream::ProcessorID;
  return id_;
}
inline ::dstream::ProcessorID* Processor::release_id() {
  clear_has_id();
  ::dstream::ProcessorID* temp = id_;
  id_ = NULL;
  return temp;
}

// optional .dstream.ProcessorRole role = 4;
inline bool Processor::has_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Processor::set_has_role() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Processor::clear_has_role() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Processor::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline dstream::ProcessorRole Processor::role() const {
  return static_cast< dstream::ProcessorRole >(role_);
}
inline void Processor::set_role(dstream::ProcessorRole value) {
  GOOGLE_DCHECK(dstream::ProcessorRole_IsValid(value));
  set_has_role();
  role_ = value;
}

// optional string exec_cmd = 5;
inline bool Processor::has_exec_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Processor::set_has_exec_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Processor::clear_has_exec_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Processor::clear_exec_cmd() {
  if (exec_cmd_ != &::google::protobuf::internal::kEmptyString) {
    exec_cmd_->clear();
  }
  clear_has_exec_cmd();
}
inline const ::std::string& Processor::exec_cmd() const {
  return *exec_cmd_;
}
inline void Processor::set_exec_cmd(const ::std::string& value) {
  set_has_exec_cmd();
  if (exec_cmd_ == &::google::protobuf::internal::kEmptyString) {
    exec_cmd_ = new ::std::string;
  }
  exec_cmd_->assign(value);
}
inline void Processor::set_exec_cmd(const char* value) {
  set_has_exec_cmd();
  if (exec_cmd_ == &::google::protobuf::internal::kEmptyString) {
    exec_cmd_ = new ::std::string;
  }
  exec_cmd_->assign(value);
}
inline void Processor::set_exec_cmd(const char* value, size_t size) {
  set_has_exec_cmd();
  if (exec_cmd_ == &::google::protobuf::internal::kEmptyString) {
    exec_cmd_ = new ::std::string;
  }
  exec_cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_exec_cmd() {
  set_has_exec_cmd();
  if (exec_cmd_ == &::google::protobuf::internal::kEmptyString) {
    exec_cmd_ = new ::std::string;
  }
  return exec_cmd_;
}
inline ::std::string* Processor::release_exec_cmd() {
  clear_has_exec_cmd();
  if (exec_cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_cmd_;
    exec_cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.Resource resource_require = 7;
inline bool Processor::has_resource_require() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Processor::set_has_resource_require() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Processor::clear_has_resource_require() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Processor::clear_resource_require() {
  if (resource_require_ != NULL) resource_require_->::dstream::Resource::Clear();
  clear_has_resource_require();
}
inline const ::dstream::Resource& Processor::resource_require() const {
  return resource_require_ != NULL ? *resource_require_ : *default_instance_->resource_require_;
}
inline ::dstream::Resource* Processor::mutable_resource_require() {
  set_has_resource_require();
  if (resource_require_ == NULL) resource_require_ = new ::dstream::Resource;
  return resource_require_;
}
inline ::dstream::Resource* Processor::release_resource_require() {
  clear_has_resource_require();
  ::dstream::Resource* temp = resource_require_;
  resource_require_ = NULL;
  return temp;
}

// optional fixed32 parallism = 8;
inline bool Processor::has_parallism() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Processor::set_has_parallism() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Processor::clear_has_parallism() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Processor::clear_parallism() {
  parallism_ = 0u;
  clear_has_parallism();
}
inline ::google::protobuf::uint32 Processor::parallism() const {
  return parallism_;
}
inline void Processor::set_parallism(::google::protobuf::uint32 value) {
  set_has_parallism();
  parallism_ = value;
}

// optional fixed32 backup_num = 9;
inline bool Processor::has_backup_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Processor::set_has_backup_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Processor::clear_has_backup_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Processor::clear_backup_num() {
  backup_num_ = 0u;
  clear_has_backup_num();
}
inline ::google::protobuf::uint32 Processor::backup_num() const {
  return backup_num_;
}
inline void Processor::set_backup_num(::google::protobuf::uint32 value) {
  set_has_backup_num();
  backup_num_ = value;
}

// optional .dstream.Publish publish = 10;
inline bool Processor::has_publish() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Processor::set_has_publish() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Processor::clear_has_publish() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Processor::clear_publish() {
  if (publish_ != NULL) publish_->::dstream::Publish::Clear();
  clear_has_publish();
}
inline const ::dstream::Publish& Processor::publish() const {
  return publish_ != NULL ? *publish_ : *default_instance_->publish_;
}
inline ::dstream::Publish* Processor::mutable_publish() {
  set_has_publish();
  if (publish_ == NULL) publish_ = new ::dstream::Publish;
  return publish_;
}
inline ::dstream::Publish* Processor::release_publish() {
  clear_has_publish();
  ::dstream::Publish* temp = publish_;
  publish_ = NULL;
  return temp;
}

// optional .dstream.Subscribe subscribe = 11;
inline bool Processor::has_subscribe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Processor::set_has_subscribe() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Processor::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Processor::clear_subscribe() {
  if (subscribe_ != NULL) subscribe_->::dstream::Subscribe::Clear();
  clear_has_subscribe();
}
inline const ::dstream::Subscribe& Processor::subscribe() const {
  return subscribe_ != NULL ? *subscribe_ : *default_instance_->subscribe_;
}
inline ::dstream::Subscribe* Processor::mutable_subscribe() {
  set_has_subscribe();
  if (subscribe_ == NULL) subscribe_ = new ::dstream::Subscribe;
  return subscribe_;
}
inline ::dstream::Subscribe* Processor::release_subscribe() {
  clear_has_subscribe();
  ::dstream::Subscribe* temp = subscribe_;
  subscribe_ = NULL;
  return temp;
}

// optional string status_mark = 12;
inline bool Processor::has_status_mark() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Processor::set_has_status_mark() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Processor::clear_has_status_mark() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Processor::clear_status_mark() {
  if (status_mark_ != &::google::protobuf::internal::kEmptyString) {
    status_mark_->clear();
  }
  clear_has_status_mark();
}
inline const ::std::string& Processor::status_mark() const {
  return *status_mark_;
}
inline void Processor::set_status_mark(const ::std::string& value) {
  set_has_status_mark();
  if (status_mark_ == &::google::protobuf::internal::kEmptyString) {
    status_mark_ = new ::std::string;
  }
  status_mark_->assign(value);
}
inline void Processor::set_status_mark(const char* value) {
  set_has_status_mark();
  if (status_mark_ == &::google::protobuf::internal::kEmptyString) {
    status_mark_ = new ::std::string;
  }
  status_mark_->assign(value);
}
inline void Processor::set_status_mark(const char* value, size_t size) {
  set_has_status_mark();
  if (status_mark_ == &::google::protobuf::internal::kEmptyString) {
    status_mark_ = new ::std::string;
  }
  status_mark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_status_mark() {
  set_has_status_mark();
  if (status_mark_ == &::google::protobuf::internal::kEmptyString) {
    status_mark_ = new ::std::string;
  }
  return status_mark_;
}
inline ::std::string* Processor::release_status_mark() {
  clear_has_status_mark();
  if (status_mark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_mark_;
    status_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 tuple_batch_count = 13;
inline bool Processor::has_tuple_batch_count() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Processor::set_has_tuple_batch_count() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Processor::clear_has_tuple_batch_count() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Processor::clear_tuple_batch_count() {
  tuple_batch_count_ = GOOGLE_ULONGLONG(0);
  clear_has_tuple_batch_count();
}
inline ::google::protobuf::uint64 Processor::tuple_batch_count() const {
  return tuple_batch_count_;
}
inline void Processor::set_tuple_batch_count(::google::protobuf::uint64 value) {
  set_has_tuple_batch_count();
  tuple_batch_count_ = value;
}

// optional fixed64 force_forward_tuples_period_ms = 14;
inline bool Processor::has_force_forward_tuples_period_ms() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Processor::set_has_force_forward_tuples_period_ms() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Processor::clear_has_force_forward_tuples_period_ms() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Processor::clear_force_forward_tuples_period_ms() {
  force_forward_tuples_period_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_force_forward_tuples_period_ms();
}
inline ::google::protobuf::uint64 Processor::force_forward_tuples_period_ms() const {
  return force_forward_tuples_period_ms_;
}
inline void Processor::set_force_forward_tuples_period_ms(::google::protobuf::uint64 value) {
  set_has_force_forward_tuples_period_ms();
  force_forward_tuples_period_ms_ = value;
}

// optional string dynamic_proto_dir = 15;
inline bool Processor::has_dynamic_proto_dir() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Processor::set_has_dynamic_proto_dir() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Processor::clear_has_dynamic_proto_dir() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Processor::clear_dynamic_proto_dir() {
  if (dynamic_proto_dir_ != &::google::protobuf::internal::kEmptyString) {
    dynamic_proto_dir_->clear();
  }
  clear_has_dynamic_proto_dir();
}
inline const ::std::string& Processor::dynamic_proto_dir() const {
  return *dynamic_proto_dir_;
}
inline void Processor::set_dynamic_proto_dir(const ::std::string& value) {
  set_has_dynamic_proto_dir();
  if (dynamic_proto_dir_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_proto_dir_ = new ::std::string;
  }
  dynamic_proto_dir_->assign(value);
}
inline void Processor::set_dynamic_proto_dir(const char* value) {
  set_has_dynamic_proto_dir();
  if (dynamic_proto_dir_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_proto_dir_ = new ::std::string;
  }
  dynamic_proto_dir_->assign(value);
}
inline void Processor::set_dynamic_proto_dir(const char* value, size_t size) {
  set_has_dynamic_proto_dir();
  if (dynamic_proto_dir_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_proto_dir_ = new ::std::string;
  }
  dynamic_proto_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_dynamic_proto_dir() {
  set_has_dynamic_proto_dir();
  if (dynamic_proto_dir_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_proto_dir_ = new ::std::string;
  }
  return dynamic_proto_dir_;
}
inline ::std::string* Processor::release_dynamic_proto_dir() {
  clear_has_dynamic_proto_dir();
  if (dynamic_proto_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dynamic_proto_dir_;
    dynamic_proto_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 send_queue_size = 16;
inline bool Processor::has_send_queue_size() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Processor::set_has_send_queue_size() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Processor::clear_has_send_queue_size() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Processor::clear_send_queue_size() {
  send_queue_size_ = GOOGLE_ULONGLONG(0);
  clear_has_send_queue_size();
}
inline ::google::protobuf::uint64 Processor::send_queue_size() const {
  return send_queue_size_;
}
inline void Processor::set_send_queue_size(::google::protobuf::uint64 value) {
  set_has_send_queue_size();
  send_queue_size_ = value;
}

// optional fixed64 recv_queue_size = 17;
inline bool Processor::has_recv_queue_size() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Processor::set_has_recv_queue_size() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Processor::clear_has_recv_queue_size() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Processor::clear_recv_queue_size() {
  recv_queue_size_ = GOOGLE_ULONGLONG(0);
  clear_has_recv_queue_size();
}
inline ::google::protobuf::uint64 Processor::recv_queue_size() const {
  return recv_queue_size_;
}
inline void Processor::set_recv_queue_size(::google::protobuf::uint64 value) {
  set_has_recv_queue_size();
  recv_queue_size_ = value;
}

// optional float send_watermark = 18;
inline bool Processor::has_send_watermark() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Processor::set_has_send_watermark() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Processor::clear_has_send_watermark() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Processor::clear_send_watermark() {
  send_watermark_ = 0;
  clear_has_send_watermark();
}
inline float Processor::send_watermark() const {
  return send_watermark_;
}
inline void Processor::set_send_watermark(float value) {
  set_has_send_watermark();
  send_watermark_ = value;
}

// optional float recv_watermark = 19;
inline bool Processor::has_recv_watermark() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Processor::set_has_recv_watermark() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Processor::clear_has_recv_watermark() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Processor::clear_recv_watermark() {
  recv_watermark_ = 0;
  clear_has_recv_watermark();
}
inline float Processor::recv_watermark() const {
  return recv_watermark_;
}
inline void Processor::set_recv_watermark(float value) {
  set_has_recv_watermark();
  recv_watermark_ = value;
}

// optional fixed64 fetch_timeout_ms = 20;
inline bool Processor::has_fetch_timeout_ms() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Processor::set_has_fetch_timeout_ms() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Processor::clear_has_fetch_timeout_ms() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Processor::clear_fetch_timeout_ms() {
  fetch_timeout_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_fetch_timeout_ms();
}
inline ::google::protobuf::uint64 Processor::fetch_timeout_ms() const {
  return fetch_timeout_ms_;
}
inline void Processor::set_fetch_timeout_ms(::google::protobuf::uint64 value) {
  set_has_fetch_timeout_ms();
  fetch_timeout_ms_ = value;
}

// optional fixed64 send_timeout_ms = 21;
inline bool Processor::has_send_timeout_ms() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Processor::set_has_send_timeout_ms() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Processor::clear_has_send_timeout_ms() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Processor::clear_send_timeout_ms() {
  send_timeout_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_send_timeout_ms();
}
inline ::google::protobuf::uint64 Processor::send_timeout_ms() const {
  return send_timeout_ms_;
}
inline void Processor::set_send_timeout_ms(::google::protobuf::uint64 value) {
  set_has_send_timeout_ms();
  send_timeout_ms_ = value;
}

// optional fixed32 exec_workers = 22;
inline bool Processor::has_exec_workers() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Processor::set_has_exec_workers() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Processor::clear_has_exec_workers() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Processor::clear_exec_workers() {
  exec_workers_ = 0u;
  clear_has_exec_workers();
}
inline ::google::protobuf::uint32 Processor::exec_workers() const {
  return exec_workers_;
}
inline void Processor::set_exec_workers(::google::protobuf::uint32 value) {
  set_has_exec_workers();
  exec_workers_ = value;
}

// optional fixed32 net_workers = 23;
inline bool Processor::has_net_workers() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Processor::set_has_net_workers() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Processor::clear_has_net_workers() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Processor::clear_net_workers() {
  net_workers_ = 0u;
  clear_has_net_workers();
}
inline ::google::protobuf::uint32 Processor::net_workers() const {
  return net_workers_;
}
inline void Processor::set_net_workers(::google::protobuf::uint32 value) {
  set_has_net_workers();
  net_workers_ = value;
}

// optional fixed32 disk_workers = 24;
inline bool Processor::has_disk_workers() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Processor::set_has_disk_workers() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Processor::clear_has_disk_workers() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Processor::clear_disk_workers() {
  disk_workers_ = 0u;
  clear_has_disk_workers();
}
inline ::google::protobuf::uint32 Processor::disk_workers() const {
  return disk_workers_;
}
inline void Processor::set_disk_workers(::google::protobuf::uint32 value) {
  set_has_disk_workers();
  disk_workers_ = value;
}

// optional fixed64 small_tran_buf_num = 25;
inline bool Processor::has_small_tran_buf_num() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Processor::set_has_small_tran_buf_num() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Processor::clear_has_small_tran_buf_num() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Processor::clear_small_tran_buf_num() {
  small_tran_buf_num_ = GOOGLE_ULONGLONG(0);
  clear_has_small_tran_buf_num();
}
inline ::google::protobuf::uint64 Processor::small_tran_buf_num() const {
  return small_tran_buf_num_;
}
inline void Processor::set_small_tran_buf_num(::google::protobuf::uint64 value) {
  set_has_small_tran_buf_num();
  small_tran_buf_num_ = value;
}

// optional fixed64 small_tran_buf_size = 26;
inline bool Processor::has_small_tran_buf_size() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Processor::set_has_small_tran_buf_size() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Processor::clear_has_small_tran_buf_size() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Processor::clear_small_tran_buf_size() {
  small_tran_buf_size_ = GOOGLE_ULONGLONG(0);
  clear_has_small_tran_buf_size();
}
inline ::google::protobuf::uint64 Processor::small_tran_buf_size() const {
  return small_tran_buf_size_;
}
inline void Processor::set_small_tran_buf_size(::google::protobuf::uint64 value) {
  set_has_small_tran_buf_size();
  small_tran_buf_size_ = value;
}

// optional fixed64 big_tran_buf_num = 27;
inline bool Processor::has_big_tran_buf_num() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Processor::set_has_big_tran_buf_num() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Processor::clear_has_big_tran_buf_num() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Processor::clear_big_tran_buf_num() {
  big_tran_buf_num_ = GOOGLE_ULONGLONG(0);
  clear_has_big_tran_buf_num();
}
inline ::google::protobuf::uint64 Processor::big_tran_buf_num() const {
  return big_tran_buf_num_;
}
inline void Processor::set_big_tran_buf_num(::google::protobuf::uint64 value) {
  set_has_big_tran_buf_num();
  big_tran_buf_num_ = value;
}

// optional float buf_low_mark = 28;
inline bool Processor::has_buf_low_mark() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Processor::set_has_buf_low_mark() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Processor::clear_has_buf_low_mark() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Processor::clear_buf_low_mark() {
  buf_low_mark_ = 0;
  clear_has_buf_low_mark();
}
inline float Processor::buf_low_mark() const {
  return buf_low_mark_;
}
inline void Processor::set_buf_low_mark(float value) {
  set_has_buf_low_mark();
  buf_low_mark_ = value;
}

// optional fixed64 tuple_batch_size = 29;
inline bool Processor::has_tuple_batch_size() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Processor::set_has_tuple_batch_size() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Processor::clear_has_tuple_batch_size() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Processor::clear_tuple_batch_size() {
  tuple_batch_size_ = GOOGLE_ULONGLONG(0);
  clear_has_tuple_batch_size();
}
inline ::google::protobuf::uint64 Processor::tuple_batch_size() const {
  return tuple_batch_size_;
}
inline void Processor::set_tuple_batch_size(::google::protobuf::uint64 value) {
  set_has_tuple_batch_size();
  tuple_batch_size_ = value;
}

// optional string pn_group = 30;
inline bool Processor::has_pn_group() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Processor::set_has_pn_group() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Processor::clear_has_pn_group() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Processor::clear_pn_group() {
  if (pn_group_ != &::google::protobuf::internal::kEmptyString) {
    pn_group_->clear();
  }
  clear_has_pn_group();
}
inline const ::std::string& Processor::pn_group() const {
  return *pn_group_;
}
inline void Processor::set_pn_group(const ::std::string& value) {
  set_has_pn_group();
  if (pn_group_ == &::google::protobuf::internal::kEmptyString) {
    pn_group_ = new ::std::string;
  }
  pn_group_->assign(value);
}
inline void Processor::set_pn_group(const char* value) {
  set_has_pn_group();
  if (pn_group_ == &::google::protobuf::internal::kEmptyString) {
    pn_group_ = new ::std::string;
  }
  pn_group_->assign(value);
}
inline void Processor::set_pn_group(const char* value, size_t size) {
  set_has_pn_group();
  if (pn_group_ == &::google::protobuf::internal::kEmptyString) {
    pn_group_ = new ::std::string;
  }
  pn_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_pn_group() {
  set_has_pn_group();
  if (pn_group_ == &::google::protobuf::internal::kEmptyString) {
    pn_group_ = new ::std::string;
  }
  return pn_group_;
}
inline ::std::string* Processor::release_pn_group() {
  clear_has_pn_group();
  if (pn_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pn_group_;
    pn_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string persist_progress = 31;
inline bool Processor::has_persist_progress() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Processor::set_has_persist_progress() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Processor::clear_has_persist_progress() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Processor::clear_persist_progress() {
  if (persist_progress_ != &::google::protobuf::internal::kEmptyString) {
    persist_progress_->clear();
  }
  clear_has_persist_progress();
}
inline const ::std::string& Processor::persist_progress() const {
  return *persist_progress_;
}
inline void Processor::set_persist_progress(const ::std::string& value) {
  set_has_persist_progress();
  if (persist_progress_ == &::google::protobuf::internal::kEmptyString) {
    persist_progress_ = new ::std::string;
  }
  persist_progress_->assign(value);
}
inline void Processor::set_persist_progress(const char* value) {
  set_has_persist_progress();
  if (persist_progress_ == &::google::protobuf::internal::kEmptyString) {
    persist_progress_ = new ::std::string;
  }
  persist_progress_->assign(value);
}
inline void Processor::set_persist_progress(const char* value, size_t size) {
  set_has_persist_progress();
  if (persist_progress_ == &::google::protobuf::internal::kEmptyString) {
    persist_progress_ = new ::std::string;
  }
  persist_progress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Processor::mutable_persist_progress() {
  set_has_persist_progress();
  if (persist_progress_ == &::google::protobuf::internal::kEmptyString) {
    persist_progress_ = new ::std::string;
  }
  return persist_progress_;
}
inline ::std::string* Processor::release_persist_progress() {
  clear_has_persist_progress();
  if (persist_progress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persist_progress_;
    persist_progress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 cur_revision = 32;
inline bool Processor::has_cur_revision() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Processor::set_has_cur_revision() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Processor::clear_has_cur_revision() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Processor::clear_cur_revision() {
  cur_revision_ = 0u;
  clear_has_cur_revision();
}
inline ::google::protobuf::uint32 Processor::cur_revision() const {
  return cur_revision_;
}
inline void Processor::set_cur_revision(::google::protobuf::uint32 value) {
  set_has_cur_revision();
  cur_revision_ = value;
}

// optional uint32 max_revision = 33;
inline bool Processor::has_max_revision() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Processor::set_has_max_revision() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Processor::clear_has_max_revision() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Processor::clear_max_revision() {
  max_revision_ = 0u;
  clear_has_max_revision();
}
inline ::google::protobuf::uint32 Processor::max_revision() const {
  return max_revision_;
}
inline void Processor::set_max_revision(::google::protobuf::uint32 value) {
  set_has_max_revision();
  max_revision_ = value;
}

// optional .dstream.FlowControl flow_control = 34;
inline bool Processor::has_flow_control() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Processor::set_has_flow_control() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Processor::clear_has_flow_control() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Processor::clear_flow_control() {
  if (flow_control_ != NULL) flow_control_->::dstream::FlowControl::Clear();
  clear_has_flow_control();
}
inline const ::dstream::FlowControl& Processor::flow_control() const {
  return flow_control_ != NULL ? *flow_control_ : *default_instance_->flow_control_;
}
inline ::dstream::FlowControl* Processor::mutable_flow_control() {
  set_has_flow_control();
  if (flow_control_ == NULL) flow_control_ = new ::dstream::FlowControl;
  return flow_control_;
}
inline ::dstream::FlowControl* Processor::release_flow_control() {
  clear_has_flow_control();
  ::dstream::FlowControl* temp = flow_control_;
  flow_control_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Publish

// repeated string tags = 1;
inline int Publish::tags_size() const {
  return tags_.size();
}
inline void Publish::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Publish::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* Publish::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void Publish::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void Publish::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void Publish::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Publish::add_tags() {
  return tags_.Add();
}
inline void Publish::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void Publish::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void Publish::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Publish::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Publish::mutable_tags() {
  return &tags_;
}

// optional string type = 2;
inline bool Publish::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Publish::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Publish::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Publish::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Publish::type() const {
  return *type_;
}
inline void Publish::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Publish::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Publish::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Publish::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Publish::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.BigpipePub bigpipe = 3;
inline bool Publish::has_bigpipe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Publish::set_has_bigpipe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Publish::clear_has_bigpipe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Publish::clear_bigpipe() {
  if (bigpipe_ != NULL) bigpipe_->::dstream::BigpipePub::Clear();
  clear_has_bigpipe();
}
inline const ::dstream::BigpipePub& Publish::bigpipe() const {
  return bigpipe_ != NULL ? *bigpipe_ : *default_instance_->bigpipe_;
}
inline ::dstream::BigpipePub* Publish::mutable_bigpipe() {
  set_has_bigpipe();
  if (bigpipe_ == NULL) bigpipe_ = new ::dstream::BigpipePub;
  return bigpipe_;
}
inline ::dstream::BigpipePub* Publish::release_bigpipe() {
  clear_has_bigpipe();
  ::dstream::BigpipePub* temp = bigpipe_;
  bigpipe_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BigpipePub

// optional string pipe_name = 1;
inline bool BigpipePub::has_pipe_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigpipePub::set_has_pipe_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigpipePub::clear_has_pipe_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigpipePub::clear_pipe_name() {
  if (pipe_name_ != &::google::protobuf::internal::kEmptyString) {
    pipe_name_->clear();
  }
  clear_has_pipe_name();
}
inline const ::std::string& BigpipePub::pipe_name() const {
  return *pipe_name_;
}
inline void BigpipePub::set_pipe_name(const ::std::string& value) {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  pipe_name_->assign(value);
}
inline void BigpipePub::set_pipe_name(const char* value) {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  pipe_name_->assign(value);
}
inline void BigpipePub::set_pipe_name(const char* value, size_t size) {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  pipe_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipePub::mutable_pipe_name() {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  return pipe_name_;
}
inline ::std::string* BigpipePub::release_pipe_name() {
  clear_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipe_name_;
    pipe_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pub_token = 2;
inline bool BigpipePub::has_pub_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigpipePub::set_has_pub_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigpipePub::clear_has_pub_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigpipePub::clear_pub_token() {
  if (pub_token_ != &::google::protobuf::internal::kEmptyString) {
    pub_token_->clear();
  }
  clear_has_pub_token();
}
inline const ::std::string& BigpipePub::pub_token() const {
  return *pub_token_;
}
inline void BigpipePub::set_pub_token(const ::std::string& value) {
  set_has_pub_token();
  if (pub_token_ == &::google::protobuf::internal::kEmptyString) {
    pub_token_ = new ::std::string;
  }
  pub_token_->assign(value);
}
inline void BigpipePub::set_pub_token(const char* value) {
  set_has_pub_token();
  if (pub_token_ == &::google::protobuf::internal::kEmptyString) {
    pub_token_ = new ::std::string;
  }
  pub_token_->assign(value);
}
inline void BigpipePub::set_pub_token(const char* value, size_t size) {
  set_has_pub_token();
  if (pub_token_ == &::google::protobuf::internal::kEmptyString) {
    pub_token_ = new ::std::string;
  }
  pub_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipePub::mutable_pub_token() {
  set_has_pub_token();
  if (pub_token_ == &::google::protobuf::internal::kEmptyString) {
    pub_token_ = new ::std::string;
  }
  return pub_token_;
}
inline ::std::string* BigpipePub::release_pub_token() {
  clear_has_pub_token();
  if (pub_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pub_token_;
    pub_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 pipelet_num = 3;
inline bool BigpipePub::has_pipelet_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigpipePub::set_has_pipelet_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigpipePub::clear_has_pipelet_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigpipePub::clear_pipelet_num() {
  pipelet_num_ = 0u;
  clear_has_pipelet_num();
}
inline ::google::protobuf::uint32 BigpipePub::pipelet_num() const {
  return pipelet_num_;
}
inline void BigpipePub::set_pipelet_num(::google::protobuf::uint32 value) {
  set_has_pipelet_num();
  pipelet_num_ = value;
}

// optional fixed32 retry_time = 4;
inline bool BigpipePub::has_retry_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BigpipePub::set_has_retry_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BigpipePub::clear_has_retry_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BigpipePub::clear_retry_time() {
  retry_time_ = 0u;
  clear_has_retry_time();
}
inline ::google::protobuf::uint32 BigpipePub::retry_time() const {
  return retry_time_;
}
inline void BigpipePub::set_retry_time(::google::protobuf::uint32 value) {
  set_has_retry_time();
  retry_time_ = value;
}

// optional fixed32 retry_interval = 5;
inline bool BigpipePub::has_retry_interval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BigpipePub::set_has_retry_interval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BigpipePub::clear_has_retry_interval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BigpipePub::clear_retry_interval() {
  retry_interval_ = 0u;
  clear_has_retry_interval();
}
inline ::google::protobuf::uint32 BigpipePub::retry_interval() const {
  return retry_interval_;
}
inline void BigpipePub::set_retry_interval(::google::protobuf::uint32 value) {
  set_has_retry_interval();
  retry_interval_ = value;
}

// optional string pub_user = 6;
inline bool BigpipePub::has_pub_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BigpipePub::set_has_pub_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BigpipePub::clear_has_pub_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BigpipePub::clear_pub_user() {
  if (pub_user_ != &::google::protobuf::internal::kEmptyString) {
    pub_user_->clear();
  }
  clear_has_pub_user();
}
inline const ::std::string& BigpipePub::pub_user() const {
  return *pub_user_;
}
inline void BigpipePub::set_pub_user(const ::std::string& value) {
  set_has_pub_user();
  if (pub_user_ == &::google::protobuf::internal::kEmptyString) {
    pub_user_ = new ::std::string;
  }
  pub_user_->assign(value);
}
inline void BigpipePub::set_pub_user(const char* value) {
  set_has_pub_user();
  if (pub_user_ == &::google::protobuf::internal::kEmptyString) {
    pub_user_ = new ::std::string;
  }
  pub_user_->assign(value);
}
inline void BigpipePub::set_pub_user(const char* value, size_t size) {
  set_has_pub_user();
  if (pub_user_ == &::google::protobuf::internal::kEmptyString) {
    pub_user_ = new ::std::string;
  }
  pub_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipePub::mutable_pub_user() {
  set_has_pub_user();
  if (pub_user_ == &::google::protobuf::internal::kEmptyString) {
    pub_user_ = new ::std::string;
  }
  return pub_user_;
}
inline ::std::string* BigpipePub::release_pub_user() {
  clear_has_pub_user();
  if (pub_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pub_user_;
    pub_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Subscribe

// repeated .dstream.BigpipeSub bigpipe = 1;
inline int Subscribe::bigpipe_size() const {
  return bigpipe_.size();
}
inline void Subscribe::clear_bigpipe() {
  bigpipe_.Clear();
}
inline const ::dstream::BigpipeSub& Subscribe::bigpipe(int index) const {
  return bigpipe_.Get(index);
}
inline ::dstream::BigpipeSub* Subscribe::mutable_bigpipe(int index) {
  return bigpipe_.Mutable(index);
}
inline ::dstream::BigpipeSub* Subscribe::add_bigpipe() {
  return bigpipe_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::BigpipeSub >&
Subscribe::bigpipe() const {
  return bigpipe_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::BigpipeSub >*
Subscribe::mutable_bigpipe() {
  return &bigpipe_;
}

// repeated .dstream.HdfsSub hdfs = 2;
inline int Subscribe::hdfs_size() const {
  return hdfs_.size();
}
inline void Subscribe::clear_hdfs() {
  hdfs_.Clear();
}
inline const ::dstream::HdfsSub& Subscribe::hdfs(int index) const {
  return hdfs_.Get(index);
}
inline ::dstream::HdfsSub* Subscribe::mutable_hdfs(int index) {
  return hdfs_.Mutable(index);
}
inline ::dstream::HdfsSub* Subscribe::add_hdfs() {
  return hdfs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::HdfsSub >&
Subscribe::hdfs() const {
  return hdfs_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::HdfsSub >*
Subscribe::mutable_hdfs() {
  return &hdfs_;
}

// repeated .dstream.ProcessorSub processor = 3;
inline int Subscribe::processor_size() const {
  return processor_.size();
}
inline void Subscribe::clear_processor() {
  processor_.Clear();
}
inline const ::dstream::ProcessorSub& Subscribe::processor(int index) const {
  return processor_.Get(index);
}
inline ::dstream::ProcessorSub* Subscribe::mutable_processor(int index) {
  return processor_.Mutable(index);
}
inline ::dstream::ProcessorSub* Subscribe::add_processor() {
  return processor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorSub >&
Subscribe::processor() const {
  return processor_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorSub >*
Subscribe::mutable_processor() {
  return &processor_;
}

// repeated .dstream.LocalSub localfile = 4;
inline int Subscribe::localfile_size() const {
  return localfile_.size();
}
inline void Subscribe::clear_localfile() {
  localfile_.Clear();
}
inline const ::dstream::LocalSub& Subscribe::localfile(int index) const {
  return localfile_.Get(index);
}
inline ::dstream::LocalSub* Subscribe::mutable_localfile(int index) {
  return localfile_.Mutable(index);
}
inline ::dstream::LocalSub* Subscribe::add_localfile() {
  return localfile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::LocalSub >&
Subscribe::localfile() const {
  return localfile_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::LocalSub >*
Subscribe::mutable_localfile() {
  return &localfile_;
}

// repeated .dstream.ScribeSub scribe = 5;
inline int Subscribe::scribe_size() const {
  return scribe_.size();
}
inline void Subscribe::clear_scribe() {
  scribe_.Clear();
}
inline const ::dstream::ScribeSub& Subscribe::scribe(int index) const {
  return scribe_.Get(index);
}
inline ::dstream::ScribeSub* Subscribe::mutable_scribe(int index) {
  return scribe_.Mutable(index);
}
inline ::dstream::ScribeSub* Subscribe::add_scribe() {
  return scribe_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::ScribeSub >&
Subscribe::scribe() const {
  return scribe_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::ScribeSub >*
Subscribe::mutable_scribe() {
  return &scribe_;
}

// repeated .dstream.FakeSub fake = 6;
inline int Subscribe::fake_size() const {
  return fake_.size();
}
inline void Subscribe::clear_fake() {
  fake_.Clear();
}
inline const ::dstream::FakeSub& Subscribe::fake(int index) const {
  return fake_.Get(index);
}
inline ::dstream::FakeSub* Subscribe::mutable_fake(int index) {
  return fake_.Mutable(index);
}
inline ::dstream::FakeSub* Subscribe::add_fake() {
  return fake_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::FakeSub >&
Subscribe::fake() const {
  return fake_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::FakeSub >*
Subscribe::mutable_fake() {
  return &fake_;
}

// -------------------------------------------------------------------

// LocalSub

// optional string path = 1;
inline bool LocalSub::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalSub::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalSub::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalSub::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& LocalSub::path() const {
  return *path_;
}
inline void LocalSub::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void LocalSub::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void LocalSub::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalSub::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* LocalSub::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 sub_point = 2;
inline bool LocalSub::has_sub_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalSub::set_has_sub_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalSub::clear_has_sub_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalSub::clear_sub_point() {
  sub_point_ = GOOGLE_ULONGLONG(0);
  clear_has_sub_point();
}
inline ::google::protobuf::uint64 LocalSub::sub_point() const {
  return sub_point_;
}
inline void LocalSub::set_sub_point(::google::protobuf::uint64 value) {
  set_has_sub_point();
  sub_point_ = value;
}

// -------------------------------------------------------------------

// ScribeSub

// optional fixed32 buffersize = 1;
inline bool ScribeSub::has_buffersize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScribeSub::set_has_buffersize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScribeSub::clear_has_buffersize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScribeSub::clear_buffersize() {
  buffersize_ = 0u;
  clear_has_buffersize();
}
inline ::google::protobuf::uint32 ScribeSub::buffersize() const {
  return buffersize_;
}
inline void ScribeSub::set_buffersize(::google::protobuf::uint32 value) {
  set_has_buffersize();
  buffersize_ = value;
}

// -------------------------------------------------------------------

// BigpipeSub

// optional string name = 1;
inline bool BigpipeSub::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigpipeSub::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigpipeSub::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigpipeSub::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BigpipeSub::name() const {
  return *name_;
}
inline void BigpipeSub::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BigpipeSub::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BigpipeSub::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipeSub::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BigpipeSub::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string username = 2;
inline bool BigpipeSub::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigpipeSub::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigpipeSub::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigpipeSub::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& BigpipeSub::username() const {
  return *username_;
}
inline void BigpipeSub::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void BigpipeSub::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void BigpipeSub::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipeSub::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* BigpipeSub::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 3;
inline bool BigpipeSub::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigpipeSub::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigpipeSub::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigpipeSub::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& BigpipeSub::password() const {
  return *password_;
}
inline void BigpipeSub::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void BigpipeSub::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void BigpipeSub::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipeSub::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* BigpipeSub::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pipelet = 4;
inline bool BigpipeSub::has_pipelet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BigpipeSub::set_has_pipelet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BigpipeSub::clear_has_pipelet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BigpipeSub::clear_pipelet() {
  if (pipelet_ != &::google::protobuf::internal::kEmptyString) {
    pipelet_->clear();
  }
  clear_has_pipelet();
}
inline const ::std::string& BigpipeSub::pipelet() const {
  return *pipelet_;
}
inline void BigpipeSub::set_pipelet(const ::std::string& value) {
  set_has_pipelet();
  if (pipelet_ == &::google::protobuf::internal::kEmptyString) {
    pipelet_ = new ::std::string;
  }
  pipelet_->assign(value);
}
inline void BigpipeSub::set_pipelet(const char* value) {
  set_has_pipelet();
  if (pipelet_ == &::google::protobuf::internal::kEmptyString) {
    pipelet_ = new ::std::string;
  }
  pipelet_->assign(value);
}
inline void BigpipeSub::set_pipelet(const char* value, size_t size) {
  set_has_pipelet();
  if (pipelet_ == &::google::protobuf::internal::kEmptyString) {
    pipelet_ = new ::std::string;
  }
  pipelet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigpipeSub::mutable_pipelet() {
  set_has_pipelet();
  if (pipelet_ == &::google::protobuf::internal::kEmptyString) {
    pipelet_ = new ::std::string;
  }
  return pipelet_;
}
inline ::std::string* BigpipeSub::release_pipelet() {
  clear_has_pipelet();
  if (pipelet_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipelet_;
    pipelet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 pipelet_num = 5;
inline bool BigpipeSub::has_pipelet_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BigpipeSub::set_has_pipelet_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BigpipeSub::clear_has_pipelet_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BigpipeSub::clear_pipelet_num() {
  pipelet_num_ = 0u;
  clear_has_pipelet_num();
}
inline ::google::protobuf::uint32 BigpipeSub::pipelet_num() const {
  return pipelet_num_;
}
inline void BigpipeSub::set_pipelet_num(::google::protobuf::uint32 value) {
  set_has_pipelet_num();
  pipelet_num_ = value;
}

// repeated fixed32 pipelet_id = 6;
inline int BigpipeSub::pipelet_id_size() const {
  return pipelet_id_.size();
}
inline void BigpipeSub::clear_pipelet_id() {
  pipelet_id_.Clear();
}
inline ::google::protobuf::uint32 BigpipeSub::pipelet_id(int index) const {
  return pipelet_id_.Get(index);
}
inline void BigpipeSub::set_pipelet_id(int index, ::google::protobuf::uint32 value) {
  pipelet_id_.Set(index, value);
}
inline void BigpipeSub::add_pipelet_id(::google::protobuf::uint32 value) {
  pipelet_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BigpipeSub::pipelet_id() const {
  return pipelet_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BigpipeSub::mutable_pipelet_id() {
  return &pipelet_id_;
}

// optional fixed64 sub_point = 7;
inline bool BigpipeSub::has_sub_point() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BigpipeSub::set_has_sub_point() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BigpipeSub::clear_has_sub_point() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BigpipeSub::clear_sub_point() {
  sub_point_ = GOOGLE_ULONGLONG(0);
  clear_has_sub_point();
}
inline ::google::protobuf::uint64 BigpipeSub::sub_point() const {
  return sub_point_;
}
inline void BigpipeSub::set_sub_point(::google::protobuf::uint64 value) {
  set_has_sub_point();
  sub_point_ = value;
}

// -------------------------------------------------------------------

// HdfsSub

// optional string path = 1;
inline bool HdfsSub::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdfsSub::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HdfsSub::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HdfsSub::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& HdfsSub::path() const {
  return *path_;
}
inline void HdfsSub::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void HdfsSub::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void HdfsSub::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HdfsSub::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* HdfsSub::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string username = 2;
inline bool HdfsSub::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdfsSub::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HdfsSub::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HdfsSub::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& HdfsSub::username() const {
  return *username_;
}
inline void HdfsSub::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void HdfsSub::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void HdfsSub::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HdfsSub::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* HdfsSub::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 3;
inline bool HdfsSub::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdfsSub::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HdfsSub::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HdfsSub::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& HdfsSub::password() const {
  return *password_;
}
inline void HdfsSub::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void HdfsSub::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void HdfsSub::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HdfsSub::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* HdfsSub::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ProcessorSub

// optional string name = 1;
inline bool ProcessorSub::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorSub::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorSub::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorSub::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProcessorSub::name() const {
  return *name_;
}
inline void ProcessorSub::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProcessorSub::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProcessorSub::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorSub::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProcessorSub::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tags = 2;
inline bool ProcessorSub::has_tags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorSub::set_has_tags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorSub::clear_has_tags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorSub::clear_tags() {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    tags_->clear();
  }
  clear_has_tags();
}
inline const ::std::string& ProcessorSub::tags() const {
  return *tags_;
}
inline void ProcessorSub::set_tags(const ::std::string& value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ProcessorSub::set_tags(const char* value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void ProcessorSub::set_tags(const char* value, size_t size) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorSub::mutable_tags() {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  return tags_;
}
inline ::std::string* ProcessorSub::release_tags() {
  clear_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tags_;
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string username = 3;
inline bool ProcessorSub::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessorSub::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessorSub::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessorSub::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ProcessorSub::username() const {
  return *username_;
}
inline void ProcessorSub::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ProcessorSub::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ProcessorSub::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorSub::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ProcessorSub::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 4;
inline bool ProcessorSub::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessorSub::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessorSub::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessorSub::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ProcessorSub::password() const {
  return *password_;
}
inline void ProcessorSub::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ProcessorSub::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ProcessorSub::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorSub::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ProcessorSub::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FakeSub

// -------------------------------------------------------------------

// Topology

// optional fixed32 processor_num = 1;
inline bool Topology::has_processor_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Topology::set_has_processor_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Topology::clear_has_processor_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Topology::clear_processor_num() {
  processor_num_ = 0u;
  clear_has_processor_num();
}
inline ::google::protobuf::uint32 Topology::processor_num() const {
  return processor_num_;
}
inline void Topology::set_processor_num(::google::protobuf::uint32 value) {
  set_has_processor_num();
  processor_num_ = value;
}

// repeated .dstream.Processor processors = 2;
inline int Topology::processors_size() const {
  return processors_.size();
}
inline void Topology::clear_processors() {
  processors_.Clear();
}
inline const ::dstream::Processor& Topology::processors(int index) const {
  return processors_.Get(index);
}
inline ::dstream::Processor* Topology::mutable_processors(int index) {
  return processors_.Mutable(index);
}
inline ::dstream::Processor* Topology::add_processors() {
  return processors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::Processor >&
Topology::processors() const {
  return processors_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::Processor >*
Topology::mutable_processors() {
  return &processors_;
}

// repeated .dstream.ProcessorID importer_id = 3;
inline int Topology::importer_id_size() const {
  return importer_id_.size();
}
inline void Topology::clear_importer_id() {
  importer_id_.Clear();
}
inline const ::dstream::ProcessorID& Topology::importer_id(int index) const {
  return importer_id_.Get(index);
}
inline ::dstream::ProcessorID* Topology::mutable_importer_id(int index) {
  return importer_id_.Mutable(index);
}
inline ::dstream::ProcessorID* Topology::add_importer_id() {
  return importer_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >&
Topology::importer_id() const {
  return importer_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >*
Topology::mutable_importer_id() {
  return &importer_id_;
}

// repeated .dstream.ProcessorID exporter_id = 4;
inline int Topology::exporter_id_size() const {
  return exporter_id_.size();
}
inline void Topology::clear_exporter_id() {
  exporter_id_.Clear();
}
inline const ::dstream::ProcessorID& Topology::exporter_id(int index) const {
  return exporter_id_.Get(index);
}
inline ::dstream::ProcessorID* Topology::mutable_exporter_id(int index) {
  return exporter_id_.Mutable(index);
}
inline ::dstream::ProcessorID* Topology::add_exporter_id() {
  return exporter_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >&
Topology::exporter_id() const {
  return exporter_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::ProcessorID >*
Topology::mutable_exporter_id() {
  return &exporter_id_;
}

// optional fixed32 upstream_bigpipe_num = 5;
inline bool Topology::has_upstream_bigpipe_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Topology::set_has_upstream_bigpipe_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Topology::clear_has_upstream_bigpipe_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Topology::clear_upstream_bigpipe_num() {
  upstream_bigpipe_num_ = 0u;
  clear_has_upstream_bigpipe_num();
}
inline ::google::protobuf::uint32 Topology::upstream_bigpipe_num() const {
  return upstream_bigpipe_num_;
}
inline void Topology::set_upstream_bigpipe_num(::google::protobuf::uint32 value) {
  set_has_upstream_bigpipe_num();
  upstream_bigpipe_num_ = value;
}

// -------------------------------------------------------------------

// FlowControl

// optional int32 qps_limit = 1 [default = -1];
inline bool FlowControl::has_qps_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowControl::set_has_qps_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowControl::clear_has_qps_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowControl::clear_qps_limit() {
  qps_limit_ = -1;
  clear_has_qps_limit();
}
inline ::google::protobuf::int32 FlowControl::qps_limit() const {
  return qps_limit_;
}
inline void FlowControl::set_qps_limit(::google::protobuf::int32 value) {
  set_has_qps_limit();
  qps_limit_ = value;
}

// -------------------------------------------------------------------

// Application

// optional fixed64 session_id = 1;
inline bool Application::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Application::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Application::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Application::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 Application::session_id() const {
  return session_id_;
}
inline void Application::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .dstream.AppID id = 2;
inline bool Application::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Application::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Application::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Application::clear_id() {
  if (id_ != NULL) id_->::dstream::AppID::Clear();
  clear_has_id();
}
inline const ::dstream::AppID& Application::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::dstream::AppID* Application::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::dstream::AppID;
  return id_;
}
inline ::dstream::AppID* Application::release_id() {
  clear_has_id();
  ::dstream::AppID* temp = id_;
  id_ = NULL;
  return temp;
}

// optional string name = 3;
inline bool Application::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Application::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Application::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Application::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Application::name() const {
  return *name_;
}
inline void Application::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Application::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Application::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Application::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Application::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string descr = 4;
inline bool Application::has_descr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Application::set_has_descr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Application::clear_has_descr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Application::clear_descr() {
  if (descr_ != &::google::protobuf::internal::kEmptyString) {
    descr_->clear();
  }
  clear_has_descr();
}
inline const ::std::string& Application::descr() const {
  return *descr_;
}
inline void Application::set_descr(const ::std::string& value) {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  descr_->assign(value);
}
inline void Application::set_descr(const char* value) {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  descr_->assign(value);
}
inline void Application::set_descr(const char* value, size_t size) {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  descr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Application::mutable_descr() {
  set_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    descr_ = new ::std::string;
  }
  return descr_;
}
inline ::std::string* Application::release_descr() {
  clear_has_descr();
  if (descr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = descr_;
    descr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.User user = 5;
inline bool Application::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Application::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Application::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Application::clear_user() {
  if (user_ != NULL) user_->::dstream::User::Clear();
  clear_has_user();
}
inline const ::dstream::User& Application::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::dstream::User* Application::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::dstream::User;
  return user_;
}
inline ::dstream::User* Application::release_user() {
  clear_has_user();
  ::dstream::User* temp = user_;
  user_ = NULL;
  return temp;
}

// optional .dstream.FileConfig app_path = 6;
inline bool Application::has_app_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Application::set_has_app_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Application::clear_has_app_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Application::clear_app_path() {
  if (app_path_ != NULL) app_path_->::dstream::FileConfig::Clear();
  clear_has_app_path();
}
inline const ::dstream::FileConfig& Application::app_path() const {
  return app_path_ != NULL ? *app_path_ : *default_instance_->app_path_;
}
inline ::dstream::FileConfig* Application::mutable_app_path() {
  set_has_app_path();
  if (app_path_ == NULL) app_path_ = new ::dstream::FileConfig;
  return app_path_;
}
inline ::dstream::FileConfig* Application::release_app_path() {
  clear_has_app_path();
  ::dstream::FileConfig* temp = app_path_;
  app_path_ = NULL;
  return temp;
}

// optional .dstream.FileConfig checkpoint_path = 7;
inline bool Application::has_checkpoint_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Application::set_has_checkpoint_path() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Application::clear_has_checkpoint_path() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Application::clear_checkpoint_path() {
  if (checkpoint_path_ != NULL) checkpoint_path_->::dstream::FileConfig::Clear();
  clear_has_checkpoint_path();
}
inline const ::dstream::FileConfig& Application::checkpoint_path() const {
  return checkpoint_path_ != NULL ? *checkpoint_path_ : *default_instance_->checkpoint_path_;
}
inline ::dstream::FileConfig* Application::mutable_checkpoint_path() {
  set_has_checkpoint_path();
  if (checkpoint_path_ == NULL) checkpoint_path_ = new ::dstream::FileConfig;
  return checkpoint_path_;
}
inline ::dstream::FileConfig* Application::release_checkpoint_path() {
  clear_has_checkpoint_path();
  ::dstream::FileConfig* temp = checkpoint_path_;
  checkpoint_path_ = NULL;
  return temp;
}

// optional .dstream.BigpipeSub bigpipe = 8;
inline bool Application::has_bigpipe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Application::set_has_bigpipe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Application::clear_has_bigpipe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Application::clear_bigpipe() {
  if (bigpipe_ != NULL) bigpipe_->::dstream::BigpipeSub::Clear();
  clear_has_bigpipe();
}
inline const ::dstream::BigpipeSub& Application::bigpipe() const {
  return bigpipe_ != NULL ? *bigpipe_ : *default_instance_->bigpipe_;
}
inline ::dstream::BigpipeSub* Application::mutable_bigpipe() {
  set_has_bigpipe();
  if (bigpipe_ == NULL) bigpipe_ = new ::dstream::BigpipeSub;
  return bigpipe_;
}
inline ::dstream::BigpipeSub* Application::release_bigpipe() {
  clear_has_bigpipe();
  ::dstream::BigpipeSub* temp = bigpipe_;
  bigpipe_ = NULL;
  return temp;
}

// optional .dstream.Topology topology = 9;
inline bool Application::has_topology() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Application::set_has_topology() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Application::clear_has_topology() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Application::clear_topology() {
  if (topology_ != NULL) topology_->::dstream::Topology::Clear();
  clear_has_topology();
}
inline const ::dstream::Topology& Application::topology() const {
  return topology_ != NULL ? *topology_ : *default_instance_->topology_;
}
inline ::dstream::Topology* Application::mutable_topology() {
  set_has_topology();
  if (topology_ == NULL) topology_ = new ::dstream::Topology;
  return topology_;
}
inline ::dstream::Topology* Application::release_topology() {
  clear_has_topology();
  ::dstream::Topology* temp = topology_;
  topology_ = NULL;
  return temp;
}

// optional .dstream.AppStatus status = 10;
inline bool Application::has_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Application::set_has_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Application::clear_has_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Application::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline dstream::AppStatus Application::status() const {
  return static_cast< dstream::AppStatus >(status_);
}
inline void Application::set_status(dstream::AppStatus value) {
  GOOGLE_DCHECK(dstream::AppStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .dstream.FileConfig log_path = 11;
inline bool Application::has_log_path() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Application::set_has_log_path() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Application::clear_has_log_path() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Application::clear_log_path() {
  if (log_path_ != NULL) log_path_->::dstream::FileConfig::Clear();
  clear_has_log_path();
}
inline const ::dstream::FileConfig& Application::log_path() const {
  return log_path_ != NULL ? *log_path_ : *default_instance_->log_path_;
}
inline ::dstream::FileConfig* Application::mutable_log_path() {
  set_has_log_path();
  if (log_path_ == NULL) log_path_ = new ::dstream::FileConfig;
  return log_path_;
}
inline ::dstream::FileConfig* Application::release_log_path() {
  clear_has_log_path();
  ::dstream::FileConfig* temp = log_path_;
  log_path_ = NULL;
  return temp;
}

// optional fixed64 submit_time = 12;
inline bool Application::has_submit_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Application::set_has_submit_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Application::clear_has_submit_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Application::clear_submit_time() {
  submit_time_ = GOOGLE_ULONGLONG(0);
  clear_has_submit_time();
}
inline ::google::protobuf::uint64 Application::submit_time() const {
  return submit_time_;
}
inline void Application::set_submit_time(::google::protobuf::uint64 value) {
  set_has_submit_time();
  submit_time_ = value;
}

// optional fixed32 data_strategy = 14;
inline bool Application::has_data_strategy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Application::set_has_data_strategy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Application::clear_has_data_strategy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Application::clear_data_strategy() {
  data_strategy_ = 0u;
  clear_has_data_strategy();
}
inline ::google::protobuf::uint32 Application::data_strategy() const {
  return data_strategy_;
}
inline void Application::set_data_strategy(::google::protobuf::uint32 value) {
  set_has_data_strategy();
  data_strategy_ = value;
}

// -------------------------------------------------------------------

// BackupPEID

// optional fixed64 id = 1;
inline bool BackupPEID::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackupPEID::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackupPEID::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackupPEID::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 BackupPEID::id() const {
  return id_;
}
inline void BackupPEID::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// BackupPE

// optional .dstream.BackupPEID backup_pe_id = 1;
inline bool BackupPE::has_backup_pe_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackupPE::set_has_backup_pe_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackupPE::clear_has_backup_pe_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackupPE::clear_backup_pe_id() {
  if (backup_pe_id_ != NULL) backup_pe_id_->::dstream::BackupPEID::Clear();
  clear_has_backup_pe_id();
}
inline const ::dstream::BackupPEID& BackupPE::backup_pe_id() const {
  return backup_pe_id_ != NULL ? *backup_pe_id_ : *default_instance_->backup_pe_id_;
}
inline ::dstream::BackupPEID* BackupPE::mutable_backup_pe_id() {
  set_has_backup_pe_id();
  if (backup_pe_id_ == NULL) backup_pe_id_ = new ::dstream::BackupPEID;
  return backup_pe_id_;
}
inline ::dstream::BackupPEID* BackupPE::release_backup_pe_id() {
  clear_has_backup_pe_id();
  ::dstream::BackupPEID* temp = backup_pe_id_;
  backup_pe_id_ = NULL;
  return temp;
}

// optional .dstream.PNID pn_id = 2;
inline bool BackupPE::has_pn_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BackupPE::set_has_pn_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BackupPE::clear_has_pn_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BackupPE::clear_pn_id() {
  if (pn_id_ != NULL) pn_id_->::dstream::PNID::Clear();
  clear_has_pn_id();
}
inline const ::dstream::PNID& BackupPE::pn_id() const {
  return pn_id_ != NULL ? *pn_id_ : *default_instance_->pn_id_;
}
inline ::dstream::PNID* BackupPE::mutable_pn_id() {
  set_has_pn_id();
  if (pn_id_ == NULL) pn_id_ = new ::dstream::PNID;
  return pn_id_;
}
inline ::dstream::PNID* BackupPE::release_pn_id() {
  clear_has_pn_id();
  ::dstream::PNID* temp = pn_id_;
  pn_id_ = NULL;
  return temp;
}

// optional fixed64 last_assignment_time = 3;
inline bool BackupPE::has_last_assignment_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BackupPE::set_has_last_assignment_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BackupPE::clear_has_last_assignment_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BackupPE::clear_last_assignment_time() {
  last_assignment_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_assignment_time();
}
inline ::google::protobuf::uint64 BackupPE::last_assignment_time() const {
  return last_assignment_time_;
}
inline void BackupPE::set_last_assignment_time(::google::protobuf::uint64 value) {
  set_has_last_assignment_time();
  last_assignment_time_ = value;
}

// optional .dstream.PEStatus pe_status = 4;
inline bool BackupPE::has_pe_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BackupPE::set_has_pe_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BackupPE::clear_has_pe_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BackupPE::clear_pe_status() {
  pe_status_ = 0;
  clear_has_pe_status();
}
inline dstream::PEStatus BackupPE::pe_status() const {
  return static_cast< dstream::PEStatus >(pe_status_);
}
inline void BackupPE::set_pe_status(dstream::PEStatus value) {
  GOOGLE_DCHECK(dstream::PEStatus_IsValid(value));
  set_has_pe_status();
  pe_status_ = value;
}

// optional string last_fail_pn = 5;
inline bool BackupPE::has_last_fail_pn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BackupPE::set_has_last_fail_pn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BackupPE::clear_has_last_fail_pn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BackupPE::clear_last_fail_pn() {
  if (last_fail_pn_ != &::google::protobuf::internal::kEmptyString) {
    last_fail_pn_->clear();
  }
  clear_has_last_fail_pn();
}
inline const ::std::string& BackupPE::last_fail_pn() const {
  return *last_fail_pn_;
}
inline void BackupPE::set_last_fail_pn(const ::std::string& value) {
  set_has_last_fail_pn();
  if (last_fail_pn_ == &::google::protobuf::internal::kEmptyString) {
    last_fail_pn_ = new ::std::string;
  }
  last_fail_pn_->assign(value);
}
inline void BackupPE::set_last_fail_pn(const char* value) {
  set_has_last_fail_pn();
  if (last_fail_pn_ == &::google::protobuf::internal::kEmptyString) {
    last_fail_pn_ = new ::std::string;
  }
  last_fail_pn_->assign(value);
}
inline void BackupPE::set_last_fail_pn(const char* value, size_t size) {
  set_has_last_fail_pn();
  if (last_fail_pn_ == &::google::protobuf::internal::kEmptyString) {
    last_fail_pn_ = new ::std::string;
  }
  last_fail_pn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackupPE::mutable_last_fail_pn() {
  set_has_last_fail_pn();
  if (last_fail_pn_ == &::google::protobuf::internal::kEmptyString) {
    last_fail_pn_ = new ::std::string;
  }
  return last_fail_pn_;
}
inline ::std::string* BackupPE::release_last_fail_pn() {
  clear_has_last_fail_pn();
  if (last_fail_pn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_fail_pn_;
    last_fail_pn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 fail_number = 6;
inline bool BackupPE::has_fail_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BackupPE::set_has_fail_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BackupPE::clear_has_fail_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BackupPE::clear_fail_number() {
  fail_number_ = 0u;
  clear_has_fail_number();
}
inline ::google::protobuf::uint32 BackupPE::fail_number() const {
  return fail_number_;
}
inline void BackupPE::set_fail_number(::google::protobuf::uint32 value) {
  set_has_fail_number();
  fail_number_ = value;
}

// -------------------------------------------------------------------

// logConfig

// optional .dstream.BigpipeSub bigpipe = 1;
inline bool logConfig::has_bigpipe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void logConfig::set_has_bigpipe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void logConfig::clear_has_bigpipe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void logConfig::clear_bigpipe() {
  if (bigpipe_ != NULL) bigpipe_->::dstream::BigpipeSub::Clear();
  clear_has_bigpipe();
}
inline const ::dstream::BigpipeSub& logConfig::bigpipe() const {
  return bigpipe_ != NULL ? *bigpipe_ : *default_instance_->bigpipe_;
}
inline ::dstream::BigpipeSub* logConfig::mutable_bigpipe() {
  set_has_bigpipe();
  if (bigpipe_ == NULL) bigpipe_ = new ::dstream::BigpipeSub;
  return bigpipe_;
}
inline ::dstream::BigpipeSub* logConfig::release_bigpipe() {
  clear_has_bigpipe();
  ::dstream::BigpipeSub* temp = bigpipe_;
  bigpipe_ = NULL;
  return temp;
}

// optional string pipe_name = 2;
inline bool logConfig::has_pipe_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void logConfig::set_has_pipe_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void logConfig::clear_has_pipe_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void logConfig::clear_pipe_name() {
  if (pipe_name_ != &::google::protobuf::internal::kEmptyString) {
    pipe_name_->clear();
  }
  clear_has_pipe_name();
}
inline const ::std::string& logConfig::pipe_name() const {
  return *pipe_name_;
}
inline void logConfig::set_pipe_name(const ::std::string& value) {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  pipe_name_->assign(value);
}
inline void logConfig::set_pipe_name(const char* value) {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  pipe_name_->assign(value);
}
inline void logConfig::set_pipe_name(const char* value, size_t size) {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  pipe_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* logConfig::mutable_pipe_name() {
  set_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    pipe_name_ = new ::std::string;
  }
  return pipe_name_;
}
inline ::std::string* logConfig::release_pipe_name() {
  clear_has_pipe_name();
  if (pipe_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipe_name_;
    pipe_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 pipelet = 3;
inline bool logConfig::has_pipelet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void logConfig::set_has_pipelet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void logConfig::clear_has_pipelet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void logConfig::clear_pipelet() {
  pipelet_ = 0u;
  clear_has_pipelet();
}
inline ::google::protobuf::uint32 logConfig::pipelet() const {
  return pipelet_;
}
inline void logConfig::set_pipelet(::google::protobuf::uint32 value) {
  set_has_pipelet();
  pipelet_ = value;
}

// -------------------------------------------------------------------

// ProcessorElement

// optional .dstream.AppID app = 1;
inline bool ProcessorElement::has_app() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorElement::set_has_app() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorElement::clear_has_app() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorElement::clear_app() {
  if (app_ != NULL) app_->::dstream::AppID::Clear();
  clear_has_app();
}
inline const ::dstream::AppID& ProcessorElement::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::dstream::AppID* ProcessorElement::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::dstream::AppID;
  return app_;
}
inline ::dstream::AppID* ProcessorElement::release_app() {
  clear_has_app();
  ::dstream::AppID* temp = app_;
  app_ = NULL;
  return temp;
}

// optional .dstream.ProcessorID processor = 2;
inline bool ProcessorElement::has_processor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorElement::set_has_processor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorElement::clear_has_processor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorElement::clear_processor() {
  if (processor_ != NULL) processor_->::dstream::ProcessorID::Clear();
  clear_has_processor();
}
inline const ::dstream::ProcessorID& ProcessorElement::processor() const {
  return processor_ != NULL ? *processor_ : *default_instance_->processor_;
}
inline ::dstream::ProcessorID* ProcessorElement::mutable_processor() {
  set_has_processor();
  if (processor_ == NULL) processor_ = new ::dstream::ProcessorID;
  return processor_;
}
inline ::dstream::ProcessorID* ProcessorElement::release_processor() {
  clear_has_processor();
  ::dstream::ProcessorID* temp = processor_;
  processor_ = NULL;
  return temp;
}

// optional .dstream.PEID pe_id = 3;
inline bool ProcessorElement::has_pe_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessorElement::set_has_pe_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessorElement::clear_has_pe_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessorElement::clear_pe_id() {
  if (pe_id_ != NULL) pe_id_->::dstream::PEID::Clear();
  clear_has_pe_id();
}
inline const ::dstream::PEID& ProcessorElement::pe_id() const {
  return pe_id_ != NULL ? *pe_id_ : *default_instance_->pe_id_;
}
inline ::dstream::PEID* ProcessorElement::mutable_pe_id() {
  set_has_pe_id();
  if (pe_id_ == NULL) pe_id_ = new ::dstream::PEID;
  return pe_id_;
}
inline ::dstream::PEID* ProcessorElement::release_pe_id() {
  clear_has_pe_id();
  ::dstream::PEID* temp = pe_id_;
  pe_id_ = NULL;
  return temp;
}

// optional fixed64 serial = 4;
inline bool ProcessorElement::has_serial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessorElement::set_has_serial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessorElement::clear_has_serial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessorElement::clear_serial() {
  serial_ = GOOGLE_ULONGLONG(0);
  clear_has_serial();
}
inline ::google::protobuf::uint64 ProcessorElement::serial() const {
  return serial_;
}
inline void ProcessorElement::set_serial(::google::protobuf::uint64 value) {
  set_has_serial();
  serial_ = value;
}

// optional .dstream.logConfig log = 5;
inline bool ProcessorElement::has_log() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessorElement::set_has_log() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessorElement::clear_has_log() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessorElement::clear_log() {
  if (log_ != NULL) log_->::dstream::logConfig::Clear();
  clear_has_log();
}
inline const ::dstream::logConfig& ProcessorElement::log() const {
  return log_ != NULL ? *log_ : *default_instance_->log_;
}
inline ::dstream::logConfig* ProcessorElement::mutable_log() {
  set_has_log();
  if (log_ == NULL) log_ = new ::dstream::logConfig;
  return log_;
}
inline ::dstream::logConfig* ProcessorElement::release_log() {
  clear_has_log();
  ::dstream::logConfig* temp = log_;
  log_ = NULL;
  return temp;
}

// repeated .dstream.BackupPE backups = 6;
inline int ProcessorElement::backups_size() const {
  return backups_.size();
}
inline void ProcessorElement::clear_backups() {
  backups_.Clear();
}
inline const ::dstream::BackupPE& ProcessorElement::backups(int index) const {
  return backups_.Get(index);
}
inline ::dstream::BackupPE* ProcessorElement::mutable_backups(int index) {
  return backups_.Mutable(index);
}
inline ::dstream::BackupPE* ProcessorElement::add_backups() {
  return backups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::BackupPE >&
ProcessorElement::backups() const {
  return backups_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::BackupPE >*
ProcessorElement::mutable_backups() {
  return &backups_;
}

// repeated .dstream.BackupPEID primary = 7;
inline int ProcessorElement::primary_size() const {
  return primary_.size();
}
inline void ProcessorElement::clear_primary() {
  primary_.Clear();
}
inline const ::dstream::BackupPEID& ProcessorElement::primary(int index) const {
  return primary_.Get(index);
}
inline ::dstream::BackupPEID* ProcessorElement::mutable_primary(int index) {
  return primary_.Mutable(index);
}
inline ::dstream::BackupPEID* ProcessorElement::add_primary() {
  return primary_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEID >&
ProcessorElement::primary() const {
  return primary_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEID >*
ProcessorElement::mutable_primary() {
  return &primary_;
}

// optional string processor_name = 8;
inline bool ProcessorElement::has_processor_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProcessorElement::set_has_processor_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProcessorElement::clear_has_processor_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProcessorElement::clear_processor_name() {
  if (processor_name_ != &::google::protobuf::internal::kEmptyString) {
    processor_name_->clear();
  }
  clear_has_processor_name();
}
inline const ::std::string& ProcessorElement::processor_name() const {
  return *processor_name_;
}
inline void ProcessorElement::set_processor_name(const ::std::string& value) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(value);
}
inline void ProcessorElement::set_processor_name(const char* value) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(value);
}
inline void ProcessorElement::set_processor_name(const char* value, size_t size) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorElement::mutable_processor_name() {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  return processor_name_;
}
inline ::std::string* ProcessorElement::release_processor_name() {
  clear_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processor_name_;
    processor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.Resource resource = 9;
inline bool ProcessorElement::has_resource() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProcessorElement::set_has_resource() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProcessorElement::clear_has_resource() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProcessorElement::clear_resource() {
  if (resource_ != NULL) resource_->::dstream::Resource::Clear();
  clear_has_resource();
}
inline const ::dstream::Resource& ProcessorElement::resource() const {
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::dstream::Resource* ProcessorElement::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::dstream::Resource;
  return resource_;
}
inline ::dstream::Resource* ProcessorElement::release_resource() {
  clear_has_resource();
  ::dstream::Resource* temp = resource_;
  resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SubPoint

// optional .dstream.PEID id = 1;
inline bool SubPoint::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubPoint::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubPoint::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubPoint::clear_id() {
  if (id_ != NULL) id_->::dstream::PEID::Clear();
  clear_has_id();
}
inline const ::dstream::PEID& SubPoint::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::dstream::PEID* SubPoint::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::dstream::PEID;
  return id_;
}
inline ::dstream::PEID* SubPoint::release_id() {
  clear_has_id();
  ::dstream::PEID* temp = id_;
  id_ = NULL;
  return temp;
}

// optional int64 msg_id = 2;
inline bool SubPoint::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubPoint::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubPoint::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubPoint::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::int64 SubPoint::msg_id() const {
  return msg_id_;
}
inline void SubPoint::set_msg_id(::google::protobuf::int64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional fixed64 seq_id = 3;
inline bool SubPoint::has_seq_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubPoint::set_has_seq_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubPoint::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubPoint::clear_seq_id() {
  seq_id_ = GOOGLE_ULONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::uint64 SubPoint::seq_id() const {
  return seq_id_;
}
inline void SubPoint::set_seq_id(::google::protobuf::uint64 value) {
  set_has_seq_id();
  seq_id_ = value;
}

// optional fixed32 pipelet = 4;
inline bool SubPoint::has_pipelet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubPoint::set_has_pipelet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubPoint::clear_has_pipelet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubPoint::clear_pipelet() {
  pipelet_ = 0u;
  clear_has_pipelet();
}
inline ::google::protobuf::uint32 SubPoint::pipelet() const {
  return pipelet_;
}
inline void SubPoint::set_pipelet(::google::protobuf::uint32 value) {
  set_has_pipelet();
  pipelet_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dstream

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< dstream::ProcessorRole>() {
  return dstream::ProcessorRole_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dstream::AppStatus>() {
  return dstream::AppStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dstream::PEStatus>() {
  return dstream::PEStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_application_2eproto__INCLUDED

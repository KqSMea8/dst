// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cluster_config.proto

#ifndef PROTOBUF_cluster_5fconfig_2eproto__INCLUDED
#define PROTOBUF_cluster_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "application.pb.h"
// @@protoc_insertion_point(includes)

namespace dstream {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cluster_5fconfig_2eproto();
void protobuf_AssignDesc_cluster_5fconfig_2eproto();
void protobuf_ShutdownFile_cluster_5fconfig_2eproto();

class ClusterConfig;
class PMMachines;
class PNMachines;
class GroupInfo;
class PNGroups;

enum GroupType {
  SHARE = 0,
  MONOPOLY = 1
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = SHARE;
const GroupType GroupType_MAX = MONOPOLY;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupType_descriptor();
inline const ::std::string& GroupType_Name(GroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupType_descriptor(), value);
}
inline bool GroupType_Parse(
    const ::std::string& name, GroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupType>(
    GroupType_descriptor(), name, value);
}
// ===================================================================

class ClusterConfig : public ::google::protobuf::Message {
 public:
  ClusterConfig();
  virtual ~ClusterConfig();
  
  ClusterConfig(const ClusterConfig& from);
  
  inline ClusterConfig& operator=(const ClusterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterConfig& default_instance();
  
  void Swap(ClusterConfig* other);
  
  // implements Message ----------------------------------------------
  
  ClusterConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterConfig& from);
  void MergeFrom(const ClusterConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.User users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::dstream::User& users(int index) const;
  inline ::dstream::User* mutable_users(int index);
  inline ::dstream::User* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::User >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::User >*
      mutable_users();
  
  // optional string hdfs_path = 2;
  inline bool has_hdfs_path() const;
  inline void clear_hdfs_path();
  static const int kHdfsPathFieldNumber = 2;
  inline const ::std::string& hdfs_path() const;
  inline void set_hdfs_path(const ::std::string& value);
  inline void set_hdfs_path(const char* value);
  inline void set_hdfs_path(const char* value, size_t size);
  inline ::std::string* mutable_hdfs_path();
  inline ::std::string* release_hdfs_path();
  
  // optional float min_host_percentage = 3;
  inline bool has_min_host_percentage() const;
  inline void clear_min_host_percentage();
  static const int kMinHostPercentageFieldNumber = 3;
  inline float min_host_percentage() const;
  inline void set_min_host_percentage(float value);
  
  // optional string hdfs_pn_log_path = 4;
  inline bool has_hdfs_pn_log_path() const;
  inline void clear_hdfs_pn_log_path();
  static const int kHdfsPnLogPathFieldNumber = 4;
  inline const ::std::string& hdfs_pn_log_path() const;
  inline void set_hdfs_pn_log_path(const ::std::string& value);
  inline void set_hdfs_pn_log_path(const char* value);
  inline void set_hdfs_pn_log_path(const char* value, size_t size);
  inline ::std::string* mutable_hdfs_pn_log_path();
  inline ::std::string* release_hdfs_pn_log_path();
  
  // optional fixed32 wait_pn_time_sec = 5;
  inline bool has_wait_pn_time_sec() const;
  inline void clear_wait_pn_time_sec();
  static const int kWaitPnTimeSecFieldNumber = 5;
  inline ::google::protobuf::uint32 wait_pn_time_sec() const;
  inline void set_wait_pn_time_sec(::google::protobuf::uint32 value);
  
  // optional fixed32 pe_failpn_max_num = 6;
  inline bool has_pe_failpn_max_num() const;
  inline void clear_pe_failpn_max_num();
  static const int kPeFailpnMaxNumFieldNumber = 6;
  inline ::google::protobuf::uint32 pe_failpn_max_num() const;
  inline void set_pe_failpn_max_num(::google::protobuf::uint32 value);
  
  // optional fixed32 pefail_reserve_time = 7;
  inline bool has_pefail_reserve_time() const;
  inline void clear_pefail_reserve_time();
  static const int kPefailReserveTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 pefail_reserve_time() const;
  inline void set_pefail_reserve_time(::google::protobuf::uint32 value);
  
  // optional fixed32 max_pe_num_per_pn = 8;
  inline bool has_max_pe_num_per_pn() const;
  inline void clear_max_pe_num_per_pn();
  static const int kMaxPeNumPerPnFieldNumber = 8;
  inline ::google::protobuf::uint32 max_pe_num_per_pn() const;
  inline void set_max_pe_num_per_pn(::google::protobuf::uint32 value);
  
  // optional fixed32 check_pn_size = 9;
  inline bool has_check_pn_size() const;
  inline void clear_check_pn_size();
  static const int kCheckPnSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 check_pn_size() const;
  inline void set_check_pn_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.ClusterConfig)
 private:
  inline void set_has_hdfs_path();
  inline void clear_has_hdfs_path();
  inline void set_has_min_host_percentage();
  inline void clear_has_min_host_percentage();
  inline void set_has_hdfs_pn_log_path();
  inline void clear_has_hdfs_pn_log_path();
  inline void set_has_wait_pn_time_sec();
  inline void clear_has_wait_pn_time_sec();
  inline void set_has_pe_failpn_max_num();
  inline void clear_has_pe_failpn_max_num();
  inline void set_has_pefail_reserve_time();
  inline void clear_has_pefail_reserve_time();
  inline void set_has_max_pe_num_per_pn();
  inline void clear_has_max_pe_num_per_pn();
  inline void set_has_check_pn_size();
  inline void clear_has_check_pn_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::User > users_;
  ::std::string* hdfs_path_;
  ::std::string* hdfs_pn_log_path_;
  float min_host_percentage_;
  ::google::protobuf::uint32 wait_pn_time_sec_;
  ::google::protobuf::uint32 pe_failpn_max_num_;
  ::google::protobuf::uint32 pefail_reserve_time_;
  ::google::protobuf::uint32 max_pe_num_per_pn_;
  ::google::protobuf::uint32 check_pn_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_cluster_5fconfig_2eproto();
  friend void protobuf_AssignDesc_cluster_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_cluster_5fconfig_2eproto();
  
  void InitAsDefaultInstance();
  static ClusterConfig* default_instance_;
};
// -------------------------------------------------------------------

class PMMachines : public ::google::protobuf::Message {
 public:
  PMMachines();
  virtual ~PMMachines();
  
  PMMachines(const PMMachines& from);
  
  inline PMMachines& operator=(const PMMachines& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PMMachines& default_instance();
  
  void Swap(PMMachines* other);
  
  // implements Message ----------------------------------------------
  
  PMMachines* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PMMachines& from);
  void MergeFrom(const PMMachines& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string pm_list = 1;
  inline int pm_list_size() const;
  inline void clear_pm_list();
  static const int kPmListFieldNumber = 1;
  inline const ::std::string& pm_list(int index) const;
  inline ::std::string* mutable_pm_list(int index);
  inline void set_pm_list(int index, const ::std::string& value);
  inline void set_pm_list(int index, const char* value);
  inline void set_pm_list(int index, const char* value, size_t size);
  inline ::std::string* add_pm_list();
  inline void add_pm_list(const ::std::string& value);
  inline void add_pm_list(const char* value);
  inline void add_pm_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pm_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pm_list();
  
  // @@protoc_insertion_point(class_scope:dstream.PMMachines)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> pm_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cluster_5fconfig_2eproto();
  friend void protobuf_AssignDesc_cluster_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_cluster_5fconfig_2eproto();
  
  void InitAsDefaultInstance();
  static PMMachines* default_instance_;
};
// -------------------------------------------------------------------

class PNMachines : public ::google::protobuf::Message {
 public:
  PNMachines();
  virtual ~PNMachines();
  
  PNMachines(const PNMachines& from);
  
  inline PNMachines& operator=(const PNMachines& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PNMachines& default_instance();
  
  void Swap(PNMachines* other);
  
  // implements Message ----------------------------------------------
  
  PNMachines* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PNMachines& from);
  void MergeFrom(const PNMachines& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string pn_list = 1;
  inline int pn_list_size() const;
  inline void clear_pn_list();
  static const int kPnListFieldNumber = 1;
  inline const ::std::string& pn_list(int index) const;
  inline ::std::string* mutable_pn_list(int index);
  inline void set_pn_list(int index, const ::std::string& value);
  inline void set_pn_list(int index, const char* value);
  inline void set_pn_list(int index, const char* value, size_t size);
  inline ::std::string* add_pn_list();
  inline void add_pn_list(const ::std::string& value);
  inline void add_pn_list(const char* value);
  inline void add_pn_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pn_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pn_list();
  
  // @@protoc_insertion_point(class_scope:dstream.PNMachines)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> pn_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cluster_5fconfig_2eproto();
  friend void protobuf_AssignDesc_cluster_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_cluster_5fconfig_2eproto();
  
  void InitAsDefaultInstance();
  static PNMachines* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::Message {
 public:
  GroupInfo();
  virtual ~GroupInfo();
  
  GroupInfo(const GroupInfo& from);
  
  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfo& default_instance();
  
  void Swap(GroupInfo* other);
  
  // implements Message ----------------------------------------------
  
  GroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  
  // repeated string pn_list = 2;
  inline int pn_list_size() const;
  inline void clear_pn_list();
  static const int kPnListFieldNumber = 2;
  inline const ::std::string& pn_list(int index) const;
  inline ::std::string* mutable_pn_list(int index);
  inline void set_pn_list(int index, const ::std::string& value);
  inline void set_pn_list(int index, const char* value);
  inline void set_pn_list(int index, const char* value, size_t size);
  inline ::std::string* add_pn_list();
  inline void add_pn_list(const ::std::string& value);
  inline void add_pn_list(const char* value);
  inline void add_pn_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pn_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pn_list();
  
  // @@protoc_insertion_point(class_scope:dstream.GroupInfo)
 private:
  inline void set_has_group_name();
  inline void clear_has_group_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* group_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pn_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_cluster_5fconfig_2eproto();
  friend void protobuf_AssignDesc_cluster_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_cluster_5fconfig_2eproto();
  
  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class PNGroups : public ::google::protobuf::Message {
 public:
  PNGroups();
  virtual ~PNGroups();
  
  PNGroups(const PNGroups& from);
  
  inline PNGroups& operator=(const PNGroups& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PNGroups& default_instance();
  
  void Swap(PNGroups* other);
  
  // implements Message ----------------------------------------------
  
  PNGroups* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PNGroups& from);
  void MergeFrom(const PNGroups& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.GroupInfo group_list = 1;
  inline int group_list_size() const;
  inline void clear_group_list();
  static const int kGroupListFieldNumber = 1;
  inline const ::dstream::GroupInfo& group_list(int index) const;
  inline ::dstream::GroupInfo* mutable_group_list(int index);
  inline ::dstream::GroupInfo* add_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::GroupInfo >&
      group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::GroupInfo >*
      mutable_group_list();
  
  // @@protoc_insertion_point(class_scope:dstream.PNGroups)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::GroupInfo > group_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cluster_5fconfig_2eproto();
  friend void protobuf_AssignDesc_cluster_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_cluster_5fconfig_2eproto();
  
  void InitAsDefaultInstance();
  static PNGroups* default_instance_;
};
// ===================================================================


// ===================================================================

// ClusterConfig

// repeated .dstream.User users = 1;
inline int ClusterConfig::users_size() const {
  return users_.size();
}
inline void ClusterConfig::clear_users() {
  users_.Clear();
}
inline const ::dstream::User& ClusterConfig::users(int index) const {
  return users_.Get(index);
}
inline ::dstream::User* ClusterConfig::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::dstream::User* ClusterConfig::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::User >&
ClusterConfig::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::User >*
ClusterConfig::mutable_users() {
  return &users_;
}

// optional string hdfs_path = 2;
inline bool ClusterConfig::has_hdfs_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterConfig::set_has_hdfs_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterConfig::clear_has_hdfs_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterConfig::clear_hdfs_path() {
  if (hdfs_path_ != &::google::protobuf::internal::kEmptyString) {
    hdfs_path_->clear();
  }
  clear_has_hdfs_path();
}
inline const ::std::string& ClusterConfig::hdfs_path() const {
  return *hdfs_path_;
}
inline void ClusterConfig::set_hdfs_path(const ::std::string& value) {
  set_has_hdfs_path();
  if (hdfs_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_path_ = new ::std::string;
  }
  hdfs_path_->assign(value);
}
inline void ClusterConfig::set_hdfs_path(const char* value) {
  set_has_hdfs_path();
  if (hdfs_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_path_ = new ::std::string;
  }
  hdfs_path_->assign(value);
}
inline void ClusterConfig::set_hdfs_path(const char* value, size_t size) {
  set_has_hdfs_path();
  if (hdfs_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_path_ = new ::std::string;
  }
  hdfs_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClusterConfig::mutable_hdfs_path() {
  set_has_hdfs_path();
  if (hdfs_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_path_ = new ::std::string;
  }
  return hdfs_path_;
}
inline ::std::string* ClusterConfig::release_hdfs_path() {
  clear_has_hdfs_path();
  if (hdfs_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hdfs_path_;
    hdfs_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float min_host_percentage = 3;
inline bool ClusterConfig::has_min_host_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClusterConfig::set_has_min_host_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClusterConfig::clear_has_min_host_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClusterConfig::clear_min_host_percentage() {
  min_host_percentage_ = 0;
  clear_has_min_host_percentage();
}
inline float ClusterConfig::min_host_percentage() const {
  return min_host_percentage_;
}
inline void ClusterConfig::set_min_host_percentage(float value) {
  set_has_min_host_percentage();
  min_host_percentage_ = value;
}

// optional string hdfs_pn_log_path = 4;
inline bool ClusterConfig::has_hdfs_pn_log_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClusterConfig::set_has_hdfs_pn_log_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClusterConfig::clear_has_hdfs_pn_log_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClusterConfig::clear_hdfs_pn_log_path() {
  if (hdfs_pn_log_path_ != &::google::protobuf::internal::kEmptyString) {
    hdfs_pn_log_path_->clear();
  }
  clear_has_hdfs_pn_log_path();
}
inline const ::std::string& ClusterConfig::hdfs_pn_log_path() const {
  return *hdfs_pn_log_path_;
}
inline void ClusterConfig::set_hdfs_pn_log_path(const ::std::string& value) {
  set_has_hdfs_pn_log_path();
  if (hdfs_pn_log_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_pn_log_path_ = new ::std::string;
  }
  hdfs_pn_log_path_->assign(value);
}
inline void ClusterConfig::set_hdfs_pn_log_path(const char* value) {
  set_has_hdfs_pn_log_path();
  if (hdfs_pn_log_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_pn_log_path_ = new ::std::string;
  }
  hdfs_pn_log_path_->assign(value);
}
inline void ClusterConfig::set_hdfs_pn_log_path(const char* value, size_t size) {
  set_has_hdfs_pn_log_path();
  if (hdfs_pn_log_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_pn_log_path_ = new ::std::string;
  }
  hdfs_pn_log_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClusterConfig::mutable_hdfs_pn_log_path() {
  set_has_hdfs_pn_log_path();
  if (hdfs_pn_log_path_ == &::google::protobuf::internal::kEmptyString) {
    hdfs_pn_log_path_ = new ::std::string;
  }
  return hdfs_pn_log_path_;
}
inline ::std::string* ClusterConfig::release_hdfs_pn_log_path() {
  clear_has_hdfs_pn_log_path();
  if (hdfs_pn_log_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hdfs_pn_log_path_;
    hdfs_pn_log_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 wait_pn_time_sec = 5;
inline bool ClusterConfig::has_wait_pn_time_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClusterConfig::set_has_wait_pn_time_sec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClusterConfig::clear_has_wait_pn_time_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClusterConfig::clear_wait_pn_time_sec() {
  wait_pn_time_sec_ = 0u;
  clear_has_wait_pn_time_sec();
}
inline ::google::protobuf::uint32 ClusterConfig::wait_pn_time_sec() const {
  return wait_pn_time_sec_;
}
inline void ClusterConfig::set_wait_pn_time_sec(::google::protobuf::uint32 value) {
  set_has_wait_pn_time_sec();
  wait_pn_time_sec_ = value;
}

// optional fixed32 pe_failpn_max_num = 6;
inline bool ClusterConfig::has_pe_failpn_max_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClusterConfig::set_has_pe_failpn_max_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClusterConfig::clear_has_pe_failpn_max_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClusterConfig::clear_pe_failpn_max_num() {
  pe_failpn_max_num_ = 0u;
  clear_has_pe_failpn_max_num();
}
inline ::google::protobuf::uint32 ClusterConfig::pe_failpn_max_num() const {
  return pe_failpn_max_num_;
}
inline void ClusterConfig::set_pe_failpn_max_num(::google::protobuf::uint32 value) {
  set_has_pe_failpn_max_num();
  pe_failpn_max_num_ = value;
}

// optional fixed32 pefail_reserve_time = 7;
inline bool ClusterConfig::has_pefail_reserve_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClusterConfig::set_has_pefail_reserve_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClusterConfig::clear_has_pefail_reserve_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClusterConfig::clear_pefail_reserve_time() {
  pefail_reserve_time_ = 0u;
  clear_has_pefail_reserve_time();
}
inline ::google::protobuf::uint32 ClusterConfig::pefail_reserve_time() const {
  return pefail_reserve_time_;
}
inline void ClusterConfig::set_pefail_reserve_time(::google::protobuf::uint32 value) {
  set_has_pefail_reserve_time();
  pefail_reserve_time_ = value;
}

// optional fixed32 max_pe_num_per_pn = 8;
inline bool ClusterConfig::has_max_pe_num_per_pn() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClusterConfig::set_has_max_pe_num_per_pn() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClusterConfig::clear_has_max_pe_num_per_pn() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClusterConfig::clear_max_pe_num_per_pn() {
  max_pe_num_per_pn_ = 0u;
  clear_has_max_pe_num_per_pn();
}
inline ::google::protobuf::uint32 ClusterConfig::max_pe_num_per_pn() const {
  return max_pe_num_per_pn_;
}
inline void ClusterConfig::set_max_pe_num_per_pn(::google::protobuf::uint32 value) {
  set_has_max_pe_num_per_pn();
  max_pe_num_per_pn_ = value;
}

// optional fixed32 check_pn_size = 9;
inline bool ClusterConfig::has_check_pn_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClusterConfig::set_has_check_pn_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClusterConfig::clear_has_check_pn_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClusterConfig::clear_check_pn_size() {
  check_pn_size_ = 0u;
  clear_has_check_pn_size();
}
inline ::google::protobuf::uint32 ClusterConfig::check_pn_size() const {
  return check_pn_size_;
}
inline void ClusterConfig::set_check_pn_size(::google::protobuf::uint32 value) {
  set_has_check_pn_size();
  check_pn_size_ = value;
}

// -------------------------------------------------------------------

// PMMachines

// repeated string pm_list = 1;
inline int PMMachines::pm_list_size() const {
  return pm_list_.size();
}
inline void PMMachines::clear_pm_list() {
  pm_list_.Clear();
}
inline const ::std::string& PMMachines::pm_list(int index) const {
  return pm_list_.Get(index);
}
inline ::std::string* PMMachines::mutable_pm_list(int index) {
  return pm_list_.Mutable(index);
}
inline void PMMachines::set_pm_list(int index, const ::std::string& value) {
  pm_list_.Mutable(index)->assign(value);
}
inline void PMMachines::set_pm_list(int index, const char* value) {
  pm_list_.Mutable(index)->assign(value);
}
inline void PMMachines::set_pm_list(int index, const char* value, size_t size) {
  pm_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PMMachines::add_pm_list() {
  return pm_list_.Add();
}
inline void PMMachines::add_pm_list(const ::std::string& value) {
  pm_list_.Add()->assign(value);
}
inline void PMMachines::add_pm_list(const char* value) {
  pm_list_.Add()->assign(value);
}
inline void PMMachines::add_pm_list(const char* value, size_t size) {
  pm_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PMMachines::pm_list() const {
  return pm_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PMMachines::mutable_pm_list() {
  return &pm_list_;
}

// -------------------------------------------------------------------

// PNMachines

// repeated string pn_list = 1;
inline int PNMachines::pn_list_size() const {
  return pn_list_.size();
}
inline void PNMachines::clear_pn_list() {
  pn_list_.Clear();
}
inline const ::std::string& PNMachines::pn_list(int index) const {
  return pn_list_.Get(index);
}
inline ::std::string* PNMachines::mutable_pn_list(int index) {
  return pn_list_.Mutable(index);
}
inline void PNMachines::set_pn_list(int index, const ::std::string& value) {
  pn_list_.Mutable(index)->assign(value);
}
inline void PNMachines::set_pn_list(int index, const char* value) {
  pn_list_.Mutable(index)->assign(value);
}
inline void PNMachines::set_pn_list(int index, const char* value, size_t size) {
  pn_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PNMachines::add_pn_list() {
  return pn_list_.Add();
}
inline void PNMachines::add_pn_list(const ::std::string& value) {
  pn_list_.Add()->assign(value);
}
inline void PNMachines::add_pn_list(const char* value) {
  pn_list_.Add()->assign(value);
}
inline void PNMachines::add_pn_list(const char* value, size_t size) {
  pn_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PNMachines::pn_list() const {
  return pn_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PNMachines::mutable_pn_list() {
  return &pn_list_;
}

// -------------------------------------------------------------------

// GroupInfo

// optional string group_name = 1;
inline bool GroupInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupInfo::group_name() const {
  return *group_name_;
}
inline void GroupInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* GroupInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string pn_list = 2;
inline int GroupInfo::pn_list_size() const {
  return pn_list_.size();
}
inline void GroupInfo::clear_pn_list() {
  pn_list_.Clear();
}
inline const ::std::string& GroupInfo::pn_list(int index) const {
  return pn_list_.Get(index);
}
inline ::std::string* GroupInfo::mutable_pn_list(int index) {
  return pn_list_.Mutable(index);
}
inline void GroupInfo::set_pn_list(int index, const ::std::string& value) {
  pn_list_.Mutable(index)->assign(value);
}
inline void GroupInfo::set_pn_list(int index, const char* value) {
  pn_list_.Mutable(index)->assign(value);
}
inline void GroupInfo::set_pn_list(int index, const char* value, size_t size) {
  pn_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::add_pn_list() {
  return pn_list_.Add();
}
inline void GroupInfo::add_pn_list(const ::std::string& value) {
  pn_list_.Add()->assign(value);
}
inline void GroupInfo::add_pn_list(const char* value) {
  pn_list_.Add()->assign(value);
}
inline void GroupInfo::add_pn_list(const char* value, size_t size) {
  pn_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupInfo::pn_list() const {
  return pn_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupInfo::mutable_pn_list() {
  return &pn_list_;
}

// -------------------------------------------------------------------

// PNGroups

// repeated .dstream.GroupInfo group_list = 1;
inline int PNGroups::group_list_size() const {
  return group_list_.size();
}
inline void PNGroups::clear_group_list() {
  group_list_.Clear();
}
inline const ::dstream::GroupInfo& PNGroups::group_list(int index) const {
  return group_list_.Get(index);
}
inline ::dstream::GroupInfo* PNGroups::mutable_group_list(int index) {
  return group_list_.Mutable(index);
}
inline ::dstream::GroupInfo* PNGroups::add_group_list() {
  return group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::GroupInfo >&
PNGroups::group_list() const {
  return group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::GroupInfo >*
PNGroups::mutable_group_list() {
  return &group_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dstream

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< dstream::GroupType>() {
  return dstream::GroupType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cluster_5fconfig_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pm_client_rpc.proto

#ifndef PROTOBUF_pm_5fclient_5frpc_2eproto__INCLUDED
#define PROTOBUF_pm_5fclient_5frpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "application.pb.h"
#include "dstream_proto_common.pb.h"
#include "pm.pb.h"
#include "pn.pb.h"
#include "pm_pn_rpc.pb.h"
// @@protoc_insertion_point(includes)

namespace dstream {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();

class Ack;
class LoginAck;
class UpdateTopology;
class NotifyPM;
class KillPE;
class UserOperation;
class UserOperationReply;
class StatusRequest;
class StatusResponse;
class FlowControlRequest;
class FlowControlResponse;
class UpdateProRequest;
class UpdateProResponse;
class UpdateProDone;
class BlackListOperationRequest;
class BlackListOperationResponse;

enum LoginAck_ErrorCode {
  LoginAck_ErrorCode_OTHER = 1,
  LoginAck_ErrorCode_VERSION_MISSMATCH = 2,
  LoginAck_ErrorCode_WRONG_USER = 3
};
bool LoginAck_ErrorCode_IsValid(int value);
const LoginAck_ErrorCode LoginAck_ErrorCode_ErrorCode_MIN = LoginAck_ErrorCode_OTHER;
const LoginAck_ErrorCode LoginAck_ErrorCode_ErrorCode_MAX = LoginAck_ErrorCode_WRONG_USER;
const int LoginAck_ErrorCode_ErrorCode_ARRAYSIZE = LoginAck_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginAck_ErrorCode_descriptor();
inline const ::std::string& LoginAck_ErrorCode_Name(LoginAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginAck_ErrorCode_descriptor(), value);
}
inline bool LoginAck_ErrorCode_Parse(
    const ::std::string& name, LoginAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginAck_ErrorCode>(
    LoginAck_ErrorCode_descriptor(), name, value);
}
enum UpdateTopology_Operation {
  UpdateTopology_Operation_ADD = 1,
  UpdateTopology_Operation_DEL = 2,
  UpdateTopology_Operation_ADD_SUB_OK = 3,
  UpdateTopology_Operation_ADD_SUB_FAIL = 4,
  UpdateTopology_Operation_DEL_SUB_OK = 5,
  UpdateTopology_Operation_DEL_SUB_FAIL = 6,
  UpdateTopology_Operation_UPDATE_PARA = 7,
  UpdateTopology_Operation_UPDATE_PARA_OK = 8,
  UpdateTopology_Operation_UPDATE_PARA_FAIL = 9
};
bool UpdateTopology_Operation_IsValid(int value);
const UpdateTopology_Operation UpdateTopology_Operation_Operation_MIN = UpdateTopology_Operation_ADD;
const UpdateTopology_Operation UpdateTopology_Operation_Operation_MAX = UpdateTopology_Operation_UPDATE_PARA_FAIL;
const int UpdateTopology_Operation_Operation_ARRAYSIZE = UpdateTopology_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpdateTopology_Operation_descriptor();
inline const ::std::string& UpdateTopology_Operation_Name(UpdateTopology_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpdateTopology_Operation_descriptor(), value);
}
inline bool UpdateTopology_Operation_Parse(
    const ::std::string& name, UpdateTopology_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateTopology_Operation>(
    UpdateTopology_Operation_descriptor(), name, value);
}
enum UserOperation_Operation {
  UserOperation_Operation_GET = 1,
  UserOperation_Operation_UPDATE = 2,
  UserOperation_Operation_ADD = 3,
  UserOperation_Operation_DELETE = 4
};
bool UserOperation_Operation_IsValid(int value);
const UserOperation_Operation UserOperation_Operation_Operation_MIN = UserOperation_Operation_GET;
const UserOperation_Operation UserOperation_Operation_Operation_MAX = UserOperation_Operation_DELETE;
const int UserOperation_Operation_Operation_ARRAYSIZE = UserOperation_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserOperation_Operation_descriptor();
inline const ::std::string& UserOperation_Operation_Name(UserOperation_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserOperation_Operation_descriptor(), value);
}
inline bool UserOperation_Operation_Parse(
    const ::std::string& name, UserOperation_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserOperation_Operation>(
    UserOperation_Operation_descriptor(), name, value);
}
enum UserOperationReply_Operation {
  UserOperationReply_Operation_GET = 1,
  UserOperationReply_Operation_UPDATE = 2,
  UserOperationReply_Operation_ADD = 3,
  UserOperationReply_Operation_DELETE = 4
};
bool UserOperationReply_Operation_IsValid(int value);
const UserOperationReply_Operation UserOperationReply_Operation_Operation_MIN = UserOperationReply_Operation_GET;
const UserOperationReply_Operation UserOperationReply_Operation_Operation_MAX = UserOperationReply_Operation_DELETE;
const int UserOperationReply_Operation_Operation_ARRAYSIZE = UserOperationReply_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserOperationReply_Operation_descriptor();
inline const ::std::string& UserOperationReply_Operation_Name(UserOperationReply_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserOperationReply_Operation_descriptor(), value);
}
inline bool UserOperationReply_Operation_Parse(
    const ::std::string& name, UserOperationReply_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserOperationReply_Operation>(
    UserOperationReply_Operation_descriptor(), name, value);
}
enum FlowControlRequest_Operation {
  FlowControlRequest_Operation_GET = 1,
  FlowControlRequest_Operation_SET = 2
};
bool FlowControlRequest_Operation_IsValid(int value);
const FlowControlRequest_Operation FlowControlRequest_Operation_Operation_MIN = FlowControlRequest_Operation_GET;
const FlowControlRequest_Operation FlowControlRequest_Operation_Operation_MAX = FlowControlRequest_Operation_SET;
const int FlowControlRequest_Operation_Operation_ARRAYSIZE = FlowControlRequest_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* FlowControlRequest_Operation_descriptor();
inline const ::std::string& FlowControlRequest_Operation_Name(FlowControlRequest_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    FlowControlRequest_Operation_descriptor(), value);
}
inline bool FlowControlRequest_Operation_Parse(
    const ::std::string& name, FlowControlRequest_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlowControlRequest_Operation>(
    FlowControlRequest_Operation_descriptor(), name, value);
}
enum BlackListOperationRequest_Operation {
  BlackListOperationRequest_Operation_GET = 1,
  BlackListOperationRequest_Operation_GET_ALL = 2,
  BlackListOperationRequest_Operation_ERASE = 3,
  BlackListOperationRequest_Operation_CLEAR = 4
};
bool BlackListOperationRequest_Operation_IsValid(int value);
const BlackListOperationRequest_Operation BlackListOperationRequest_Operation_Operation_MIN = BlackListOperationRequest_Operation_GET;
const BlackListOperationRequest_Operation BlackListOperationRequest_Operation_Operation_MAX = BlackListOperationRequest_Operation_CLEAR;
const int BlackListOperationRequest_Operation_Operation_ARRAYSIZE = BlackListOperationRequest_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlackListOperationRequest_Operation_descriptor();
inline const ::std::string& BlackListOperationRequest_Operation_Name(BlackListOperationRequest_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlackListOperationRequest_Operation_descriptor(), value);
}
inline bool BlackListOperationRequest_Operation_Parse(
    const ::std::string& name, BlackListOperationRequest_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlackListOperationRequest_Operation>(
    BlackListOperationRequest_Operation_descriptor(), name, value);
}
// ===================================================================

class Ack : public ::google::protobuf::Message {
 public:
  Ack();
  virtual ~Ack();
  
  Ack(const Ack& from);
  
  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack& default_instance();
  
  void Swap(Ack* other);
  
  // implements Message ----------------------------------------------
  
  Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ack& from);
  void MergeFrom(const Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:dstream.Ack)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static Ack* default_instance_;
};
// -------------------------------------------------------------------

class LoginAck : public ::google::protobuf::Message {
 public:
  LoginAck();
  virtual ~LoginAck();
  
  LoginAck(const LoginAck& from);
  
  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginAck& default_instance();
  
  void Swap(LoginAck* other);
  
  // implements Message ----------------------------------------------
  
  LoginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LoginAck_ErrorCode ErrorCode;
  static const ErrorCode OTHER = LoginAck_ErrorCode_OTHER;
  static const ErrorCode VERSION_MISSMATCH = LoginAck_ErrorCode_VERSION_MISSMATCH;
  static const ErrorCode WRONG_USER = LoginAck_ErrorCode_WRONG_USER;
  static inline bool ErrorCode_IsValid(int value) {
    return LoginAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    LoginAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    LoginAck_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    LoginAck_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return LoginAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return LoginAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return LoginAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.User user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::dstream::User& user() const;
  inline ::dstream::User* mutable_user();
  inline ::dstream::User* release_user();
  
  // optional .dstream.LoginAck.ErrorCode code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::dstream::LoginAck_ErrorCode code() const;
  inline void set_code(::dstream::LoginAck_ErrorCode value);
  
  // @@protoc_insertion_point(class_scope:dstream.LoginAck)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_code();
  inline void clear_has_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::User* user_;
  int code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static LoginAck* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTopology : public ::google::protobuf::Message {
 public:
  UpdateTopology();
  virtual ~UpdateTopology();
  
  UpdateTopology(const UpdateTopology& from);
  
  inline UpdateTopology& operator=(const UpdateTopology& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTopology& default_instance();
  
  void Swap(UpdateTopology* other);
  
  // implements Message ----------------------------------------------
  
  UpdateTopology* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTopology& from);
  void MergeFrom(const UpdateTopology& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UpdateTopology_Operation Operation;
  static const Operation ADD = UpdateTopology_Operation_ADD;
  static const Operation DEL = UpdateTopology_Operation_DEL;
  static const Operation ADD_SUB_OK = UpdateTopology_Operation_ADD_SUB_OK;
  static const Operation ADD_SUB_FAIL = UpdateTopology_Operation_ADD_SUB_FAIL;
  static const Operation DEL_SUB_OK = UpdateTopology_Operation_DEL_SUB_OK;
  static const Operation DEL_SUB_FAIL = UpdateTopology_Operation_DEL_SUB_FAIL;
  static const Operation UPDATE_PARA = UpdateTopology_Operation_UPDATE_PARA;
  static const Operation UPDATE_PARA_OK = UpdateTopology_Operation_UPDATE_PARA_OK;
  static const Operation UPDATE_PARA_FAIL = UpdateTopology_Operation_UPDATE_PARA_FAIL;
  static inline bool Operation_IsValid(int value) {
    return UpdateTopology_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    UpdateTopology_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    UpdateTopology_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    UpdateTopology_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return UpdateTopology_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return UpdateTopology_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return UpdateTopology_Operation_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional .dstream.UpdateTopology.Operation type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::dstream::UpdateTopology_Operation type() const;
  inline void set_type(::dstream::UpdateTopology_Operation value);
  
  // optional .dstream.Application app = 3;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 3;
  inline const ::dstream::Application& app() const;
  inline ::dstream::Application* mutable_app();
  inline ::dstream::Application* release_app();
  
  // optional int32 error_num = 4;
  inline bool has_error_num() const;
  inline void clear_error_num();
  static const int kErrorNumFieldNumber = 4;
  inline ::google::protobuf::int32 error_num() const;
  inline void set_error_num(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.UpdateTopology)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_error_num();
  inline void clear_has_error_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::dstream::Application* app_;
  int type_;
  ::google::protobuf::int32 error_num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateTopology* default_instance_;
};
// -------------------------------------------------------------------

class NotifyPM : public ::google::protobuf::Message {
 public:
  NotifyPM();
  virtual ~NotifyPM();
  
  NotifyPM(const NotifyPM& from);
  
  inline NotifyPM& operator=(const NotifyPM& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyPM& default_instance();
  
  void Swap(NotifyPM* other);
  
  // implements Message ----------------------------------------------
  
  NotifyPM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyPM& from);
  void MergeFrom(const NotifyPM& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional string status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // @@protoc_insertion_point(class_scope:dstream.NotifyPM)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::std::string* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static NotifyPM* default_instance_;
};
// -------------------------------------------------------------------

class KillPE : public ::google::protobuf::Message {
 public:
  KillPE();
  virtual ~KillPE();
  
  KillPE(const KillPE& from);
  
  inline KillPE& operator=(const KillPE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KillPE& default_instance();
  
  void Swap(KillPE* other);
  
  // implements Message ----------------------------------------------
  
  KillPE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KillPE& from);
  void MergeFrom(const KillPE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.AppID app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline const ::dstream::AppID& app_id() const;
  inline ::dstream::AppID* mutable_app_id();
  inline ::dstream::AppID* release_app_id();
  
  // optional .dstream.PEID pe_id = 2;
  inline bool has_pe_id() const;
  inline void clear_pe_id();
  static const int kPeIdFieldNumber = 2;
  inline const ::dstream::PEID& pe_id() const;
  inline ::dstream::PEID* mutable_pe_id();
  inline ::dstream::PEID* release_pe_id();
  
  // optional .dstream.BackupPEID backup_pe_id = 3;
  inline bool has_backup_pe_id() const;
  inline void clear_backup_pe_id();
  static const int kBackupPeIdFieldNumber = 3;
  inline const ::dstream::BackupPEID& backup_pe_id() const;
  inline ::dstream::BackupPEID* mutable_backup_pe_id();
  inline ::dstream::BackupPEID* release_backup_pe_id();
  
  // optional .dstream.PNID pn_id = 4;
  inline bool has_pn_id() const;
  inline void clear_pn_id();
  static const int kPnIdFieldNumber = 4;
  inline const ::dstream::PNID& pn_id() const;
  inline ::dstream::PNID* mutable_pn_id();
  inline ::dstream::PNID* release_pn_id();
  
  // @@protoc_insertion_point(class_scope:dstream.KillPE)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_pe_id();
  inline void clear_has_pe_id();
  inline void set_has_backup_pe_id();
  inline void clear_has_backup_pe_id();
  inline void set_has_pn_id();
  inline void clear_has_pn_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::AppID* app_id_;
  ::dstream::PEID* pe_id_;
  ::dstream::BackupPEID* backup_pe_id_;
  ::dstream::PNID* pn_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static KillPE* default_instance_;
};
// -------------------------------------------------------------------

class UserOperation : public ::google::protobuf::Message {
 public:
  UserOperation();
  virtual ~UserOperation();
  
  UserOperation(const UserOperation& from);
  
  inline UserOperation& operator=(const UserOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOperation& default_instance();
  
  void Swap(UserOperation* other);
  
  // implements Message ----------------------------------------------
  
  UserOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOperation& from);
  void MergeFrom(const UserOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UserOperation_Operation Operation;
  static const Operation GET = UserOperation_Operation_GET;
  static const Operation UPDATE = UserOperation_Operation_UPDATE;
  static const Operation ADD = UserOperation_Operation_ADD;
  static const Operation DELETE = UserOperation_Operation_DELETE;
  static inline bool Operation_IsValid(int value) {
    return UserOperation_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    UserOperation_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    UserOperation_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    UserOperation_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return UserOperation_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return UserOperation_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return UserOperation_Operation_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.UserOperation.Operation type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::dstream::UserOperation_Operation type() const;
  inline void set_type(::dstream::UserOperation_Operation value);
  
  // optional .dstream.User user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::dstream::User& user() const;
  inline ::dstream::User* mutable_user();
  inline ::dstream::User* release_user();
  
  // @@protoc_insertion_point(class_scope:dstream.UserOperation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user();
  inline void clear_has_user();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::User* user_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static UserOperation* default_instance_;
};
// -------------------------------------------------------------------

class UserOperationReply : public ::google::protobuf::Message {
 public:
  UserOperationReply();
  virtual ~UserOperationReply();
  
  UserOperationReply(const UserOperationReply& from);
  
  inline UserOperationReply& operator=(const UserOperationReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOperationReply& default_instance();
  
  void Swap(UserOperationReply* other);
  
  // implements Message ----------------------------------------------
  
  UserOperationReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOperationReply& from);
  void MergeFrom(const UserOperationReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UserOperationReply_Operation Operation;
  static const Operation GET = UserOperationReply_Operation_GET;
  static const Operation UPDATE = UserOperationReply_Operation_UPDATE;
  static const Operation ADD = UserOperationReply_Operation_ADD;
  static const Operation DELETE = UserOperationReply_Operation_DELETE;
  static inline bool Operation_IsValid(int value) {
    return UserOperationReply_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    UserOperationReply_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    UserOperationReply_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    UserOperationReply_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return UserOperationReply_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return UserOperationReply_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return UserOperationReply_Operation_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.UserOperationReply.Operation replytype = 1;
  inline bool has_replytype() const;
  inline void clear_replytype();
  static const int kReplytypeFieldNumber = 1;
  inline ::dstream::UserOperationReply_Operation replytype() const;
  inline void set_replytype(::dstream::UserOperationReply_Operation value);
  
  // repeated .dstream.User user = 2;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::dstream::User& user(int index) const;
  inline ::dstream::User* mutable_user(int index);
  inline ::dstream::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::User >*
      mutable_user();
  
  // @@protoc_insertion_point(class_scope:dstream.UserOperationReply)
 private:
  inline void set_has_replytype();
  inline void clear_has_replytype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::User > user_;
  int replytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static UserOperationReply* default_instance_;
};
// -------------------------------------------------------------------

class StatusRequest : public ::google::protobuf::Message {
 public:
  StatusRequest();
  virtual ~StatusRequest();
  
  StatusRequest(const StatusRequest& from);
  
  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();
  
  void Swap(StatusRequest* other);
  
  // implements Message ----------------------------------------------
  
  StatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.PEID pe_id = 1;
  inline int pe_id_size() const;
  inline void clear_pe_id();
  static const int kPeIdFieldNumber = 1;
  inline const ::dstream::PEID& pe_id(int index) const;
  inline ::dstream::PEID* mutable_pe_id(int index);
  inline ::dstream::PEID* add_pe_id();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
      pe_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
      mutable_pe_id();
  
  // repeated .dstream.PNID pn_id = 2;
  inline int pn_id_size() const;
  inline void clear_pn_id();
  static const int kPnIdFieldNumber = 2;
  inline const ::dstream::PNID& pn_id(int index) const;
  inline ::dstream::PNID* mutable_pn_id(int index);
  inline ::dstream::PNID* add_pn_id();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PNID >&
      pn_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PNID >*
      mutable_pn_id();
  
  // @@protoc_insertion_point(class_scope:dstream.StatusRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::PEID > pe_id_;
  ::google::protobuf::RepeatedPtrField< ::dstream::PNID > pn_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static StatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message {
 public:
  StatusResponse();
  virtual ~StatusResponse();
  
  StatusResponse(const StatusResponse& from);
  
  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();
  
  void Swap(StatusResponse* other);
  
  // implements Message ----------------------------------------------
  
  StatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.BackupPEStatus pe_status_list = 1;
  inline int pe_status_list_size() const;
  inline void clear_pe_status_list();
  static const int kPeStatusListFieldNumber = 1;
  inline const ::dstream::BackupPEStatus& pe_status_list(int index) const;
  inline ::dstream::BackupPEStatus* mutable_pe_status_list(int index);
  inline ::dstream::BackupPEStatus* add_pe_status_list();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEStatus >&
      pe_status_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEStatus >*
      mutable_pe_status_list();
  
  // repeated .dstream.PNReport pn_report_list = 2;
  inline int pn_report_list_size() const;
  inline void clear_pn_report_list();
  static const int kPnReportListFieldNumber = 2;
  inline const ::dstream::PNReport& pn_report_list(int index) const;
  inline ::dstream::PNReport* mutable_pn_report_list(int index);
  inline ::dstream::PNReport* add_pn_report_list();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PNReport >&
      pn_report_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PNReport >*
      mutable_pn_report_list();
  
  // @@protoc_insertion_point(class_scope:dstream.StatusResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEStatus > pe_status_list_;
  ::google::protobuf::RepeatedPtrField< ::dstream::PNReport > pn_report_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static StatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class FlowControlRequest : public ::google::protobuf::Message {
 public:
  FlowControlRequest();
  virtual ~FlowControlRequest();
  
  FlowControlRequest(const FlowControlRequest& from);
  
  inline FlowControlRequest& operator=(const FlowControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowControlRequest& default_instance();
  
  void Swap(FlowControlRequest* other);
  
  // implements Message ----------------------------------------------
  
  FlowControlRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowControlRequest& from);
  void MergeFrom(const FlowControlRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlowControlRequest_Operation Operation;
  static const Operation GET = FlowControlRequest_Operation_GET;
  static const Operation SET = FlowControlRequest_Operation_SET;
  static inline bool Operation_IsValid(int value) {
    return FlowControlRequest_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    FlowControlRequest_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    FlowControlRequest_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    FlowControlRequest_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return FlowControlRequest_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return FlowControlRequest_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return FlowControlRequest_Operation_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional .dstream.AppID app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline const ::dstream::AppID& app_id() const;
  inline ::dstream::AppID* mutable_app_id();
  inline ::dstream::AppID* release_app_id();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string processor = 4;
  inline bool has_processor() const;
  inline void clear_processor();
  static const int kProcessorFieldNumber = 4;
  inline const ::std::string& processor() const;
  inline void set_processor(const ::std::string& value);
  inline void set_processor(const char* value);
  inline void set_processor(const char* value, size_t size);
  inline ::std::string* mutable_processor();
  inline ::std::string* release_processor();
  
  // optional int32 limit = 5;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 5;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional .dstream.FlowControlRequest.Operation cmd = 6 [default = GET];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 6;
  inline ::dstream::FlowControlRequest_Operation cmd() const;
  inline void set_cmd(::dstream::FlowControlRequest_Operation value);
  
  // @@protoc_insertion_point(class_scope:dstream.FlowControlRequest)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_processor();
  inline void clear_has_processor();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::dstream::AppID* app_id_;
  ::std::string* name_;
  ::std::string* processor_;
  ::google::protobuf::int32 limit_;
  int cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static FlowControlRequest* default_instance_;
};
// -------------------------------------------------------------------

class FlowControlResponse : public ::google::protobuf::Message {
 public:
  FlowControlResponse();
  virtual ~FlowControlResponse();
  
  FlowControlResponse(const FlowControlResponse& from);
  
  inline FlowControlResponse& operator=(const FlowControlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowControlResponse& default_instance();
  
  void Swap(FlowControlResponse* other);
  
  // implements Message ----------------------------------------------
  
  FlowControlResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowControlResponse& from);
  void MergeFrom(const FlowControlResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.AppID app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline const ::dstream::AppID& app_id() const;
  inline ::dstream::AppID* mutable_app_id();
  inline ::dstream::AppID* release_app_id();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string processor = 3;
  inline bool has_processor() const;
  inline void clear_processor();
  static const int kProcessorFieldNumber = 3;
  inline const ::std::string& processor() const;
  inline void set_processor(const ::std::string& value);
  inline void set_processor(const char* value);
  inline void set_processor(const char* value, size_t size);
  inline ::std::string* mutable_processor();
  inline ::std::string* release_processor();
  
  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.FlowControlResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_processor();
  inline void clear_has_processor();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::AppID* app_id_;
  ::std::string* name_;
  ::std::string* processor_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static FlowControlResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateProRequest : public ::google::protobuf::Message {
 public:
  UpdateProRequest();
  virtual ~UpdateProRequest();
  
  UpdateProRequest(const UpdateProRequest& from);
  
  inline UpdateProRequest& operator=(const UpdateProRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateProRequest& default_instance();
  
  void Swap(UpdateProRequest* other);
  
  // implements Message ----------------------------------------------
  
  UpdateProRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateProRequest& from);
  void MergeFrom(const UpdateProRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional .dstream.Application app = 2;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 2;
  inline const ::dstream::Application& app() const;
  inline ::dstream::Application* mutable_app();
  inline ::dstream::Application* release_app();
  
  // optional string processor_name = 3;
  inline bool has_processor_name() const;
  inline void clear_processor_name();
  static const int kProcessorNameFieldNumber = 3;
  inline const ::std::string& processor_name() const;
  inline void set_processor_name(const ::std::string& value);
  inline void set_processor_name(const char* value);
  inline void set_processor_name(const char* value, size_t size);
  inline ::std::string* mutable_processor_name();
  inline ::std::string* release_processor_name();
  
  // optional uint32 revision = 4;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 4;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.UpdateProRequest)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_processor_name();
  inline void clear_has_processor_name();
  inline void set_has_revision();
  inline void clear_has_revision();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::dstream::Application* app_;
  ::std::string* processor_name_;
  ::google::protobuf::uint32 revision_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateProRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateProResponse : public ::google::protobuf::Message {
 public:
  UpdateProResponse();
  virtual ~UpdateProResponse();
  
  UpdateProResponse(const UpdateProResponse& from);
  
  inline UpdateProResponse& operator=(const UpdateProResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateProResponse& default_instance();
  
  void Swap(UpdateProResponse* other);
  
  // implements Message ----------------------------------------------
  
  UpdateProResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateProResponse& from);
  void MergeFrom(const UpdateProResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 error_num = 1;
  inline bool has_error_num() const;
  inline void clear_error_num();
  static const int kErrorNumFieldNumber = 1;
  inline ::google::protobuf::int32 error_num() const;
  inline void set_error_num(::google::protobuf::int32 value);
  
  // optional uint32 revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.UpdateProResponse)
 private:
  inline void set_has_error_num();
  inline void clear_has_error_num();
  inline void set_has_revision();
  inline void clear_has_revision();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 error_num_;
  ::google::protobuf::uint32 revision_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateProResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateProDone : public ::google::protobuf::Message {
 public:
  UpdateProDone();
  virtual ~UpdateProDone();
  
  UpdateProDone(const UpdateProDone& from);
  
  inline UpdateProDone& operator=(const UpdateProDone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateProDone& default_instance();
  
  void Swap(UpdateProDone* other);
  
  // implements Message ----------------------------------------------
  
  UpdateProDone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateProDone& from);
  void MergeFrom(const UpdateProDone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional string status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // optional .dstream.Application app = 3;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 3;
  inline const ::dstream::Application& app() const;
  inline ::dstream::Application* mutable_app();
  inline ::dstream::Application* release_app();
  
  // optional string processor_name = 4;
  inline bool has_processor_name() const;
  inline void clear_processor_name();
  static const int kProcessorNameFieldNumber = 4;
  inline const ::std::string& processor_name() const;
  inline void set_processor_name(const ::std::string& value);
  inline void set_processor_name(const char* value);
  inline void set_processor_name(const char* value, size_t size);
  inline ::std::string* mutable_processor_name();
  inline ::std::string* release_processor_name();
  
  // optional uint32 revision = 5;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 5;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.UpdateProDone)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_processor_name();
  inline void clear_has_processor_name();
  inline void set_has_revision();
  inline void clear_has_revision();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_id_;
  ::std::string* status_;
  ::dstream::Application* app_;
  ::std::string* processor_name_;
  ::google::protobuf::uint32 revision_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateProDone* default_instance_;
};
// -------------------------------------------------------------------

class BlackListOperationRequest : public ::google::protobuf::Message {
 public:
  BlackListOperationRequest();
  virtual ~BlackListOperationRequest();
  
  BlackListOperationRequest(const BlackListOperationRequest& from);
  
  inline BlackListOperationRequest& operator=(const BlackListOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackListOperationRequest& default_instance();
  
  void Swap(BlackListOperationRequest* other);
  
  // implements Message ----------------------------------------------
  
  BlackListOperationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlackListOperationRequest& from);
  void MergeFrom(const BlackListOperationRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BlackListOperationRequest_Operation Operation;
  static const Operation GET = BlackListOperationRequest_Operation_GET;
  static const Operation GET_ALL = BlackListOperationRequest_Operation_GET_ALL;
  static const Operation ERASE = BlackListOperationRequest_Operation_ERASE;
  static const Operation CLEAR = BlackListOperationRequest_Operation_CLEAR;
  static inline bool Operation_IsValid(int value) {
    return BlackListOperationRequest_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    BlackListOperationRequest_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    BlackListOperationRequest_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    BlackListOperationRequest_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return BlackListOperationRequest_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return BlackListOperationRequest_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return BlackListOperationRequest_Operation_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.PEID pe_id = 1;
  inline int pe_id_size() const;
  inline void clear_pe_id();
  static const int kPeIdFieldNumber = 1;
  inline const ::dstream::PEID& pe_id(int index) const;
  inline ::dstream::PEID* mutable_pe_id(int index);
  inline ::dstream::PEID* add_pe_id();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
      pe_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
      mutable_pe_id();
  
  // optional .dstream.BlackListOperationRequest.Operation operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::dstream::BlackListOperationRequest_Operation operation() const;
  inline void set_operation(::dstream::BlackListOperationRequest_Operation value);
  
  // @@protoc_insertion_point(class_scope:dstream.BlackListOperationRequest)
 private:
  inline void set_has_operation();
  inline void clear_has_operation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::PEID > pe_id_;
  int operation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static BlackListOperationRequest* default_instance_;
};
// -------------------------------------------------------------------

class BlackListOperationResponse : public ::google::protobuf::Message {
 public:
  BlackListOperationResponse();
  virtual ~BlackListOperationResponse();
  
  BlackListOperationResponse(const BlackListOperationResponse& from);
  
  inline BlackListOperationResponse& operator=(const BlackListOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackListOperationResponse& default_instance();
  
  void Swap(BlackListOperationResponse* other);
  
  // implements Message ----------------------------------------------
  
  BlackListOperationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlackListOperationResponse& from);
  void MergeFrom(const BlackListOperationResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.PEPNBlackList pe_pn_blacklist = 1;
  inline int pe_pn_blacklist_size() const;
  inline void clear_pe_pn_blacklist();
  static const int kPePnBlacklistFieldNumber = 1;
  inline const ::dstream::PEPNBlackList& pe_pn_blacklist(int index) const;
  inline ::dstream::PEPNBlackList* mutable_pe_pn_blacklist(int index);
  inline ::dstream::PEPNBlackList* add_pe_pn_blacklist();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEPNBlackList >&
      pe_pn_blacklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEPNBlackList >*
      mutable_pe_pn_blacklist();
  
  // @@protoc_insertion_point(class_scope:dstream.BlackListOperationResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::PEPNBlackList > pe_pn_blacklist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_AssignDesc_pm_5fclient_5frpc_2eproto();
  friend void protobuf_ShutdownFile_pm_5fclient_5frpc_2eproto();
  
  void InitAsDefaultInstance();
  static BlackListOperationResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Ack

// -------------------------------------------------------------------

// LoginAck

// optional .dstream.User user = 1;
inline bool LoginAck::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAck::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAck::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAck::clear_user() {
  if (user_ != NULL) user_->::dstream::User::Clear();
  clear_has_user();
}
inline const ::dstream::User& LoginAck::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::dstream::User* LoginAck::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::dstream::User;
  return user_;
}
inline ::dstream::User* LoginAck::release_user() {
  clear_has_user();
  ::dstream::User* temp = user_;
  user_ = NULL;
  return temp;
}

// optional .dstream.LoginAck.ErrorCode code = 2;
inline bool LoginAck::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAck::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAck::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::dstream::LoginAck_ErrorCode LoginAck::code() const {
  return static_cast< ::dstream::LoginAck_ErrorCode >(code_);
}
inline void LoginAck::set_code(::dstream::LoginAck_ErrorCode value) {
  GOOGLE_DCHECK(::dstream::LoginAck_ErrorCode_IsValid(value));
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// UpdateTopology

// optional fixed64 session_id = 1;
inline bool UpdateTopology::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTopology::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTopology::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTopology::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 UpdateTopology::session_id() const {
  return session_id_;
}
inline void UpdateTopology::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .dstream.UpdateTopology.Operation type = 2;
inline bool UpdateTopology::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTopology::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTopology::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTopology::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::dstream::UpdateTopology_Operation UpdateTopology::type() const {
  return static_cast< ::dstream::UpdateTopology_Operation >(type_);
}
inline void UpdateTopology::set_type(::dstream::UpdateTopology_Operation value) {
  GOOGLE_DCHECK(::dstream::UpdateTopology_Operation_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .dstream.Application app = 3;
inline bool UpdateTopology::has_app() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateTopology::set_has_app() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateTopology::clear_has_app() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateTopology::clear_app() {
  if (app_ != NULL) app_->::dstream::Application::Clear();
  clear_has_app();
}
inline const ::dstream::Application& UpdateTopology::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::dstream::Application* UpdateTopology::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::dstream::Application;
  return app_;
}
inline ::dstream::Application* UpdateTopology::release_app() {
  clear_has_app();
  ::dstream::Application* temp = app_;
  app_ = NULL;
  return temp;
}

// optional int32 error_num = 4;
inline bool UpdateTopology::has_error_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateTopology::set_has_error_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateTopology::clear_has_error_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateTopology::clear_error_num() {
  error_num_ = 0;
  clear_has_error_num();
}
inline ::google::protobuf::int32 UpdateTopology::error_num() const {
  return error_num_;
}
inline void UpdateTopology::set_error_num(::google::protobuf::int32 value) {
  set_has_error_num();
  error_num_ = value;
}

// -------------------------------------------------------------------

// NotifyPM

// optional fixed64 session_id = 1;
inline bool NotifyPM::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyPM::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyPM::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyPM::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 NotifyPM::session_id() const {
  return session_id_;
}
inline void NotifyPM::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional string status = 2;
inline bool NotifyPM::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyPM::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyPM::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyPM::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& NotifyPM::status() const {
  return *status_;
}
inline void NotifyPM::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void NotifyPM::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void NotifyPM::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyPM::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* NotifyPM::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// KillPE

// optional .dstream.AppID app_id = 1;
inline bool KillPE::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillPE::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillPE::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillPE::clear_app_id() {
  if (app_id_ != NULL) app_id_->::dstream::AppID::Clear();
  clear_has_app_id();
}
inline const ::dstream::AppID& KillPE::app_id() const {
  return app_id_ != NULL ? *app_id_ : *default_instance_->app_id_;
}
inline ::dstream::AppID* KillPE::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == NULL) app_id_ = new ::dstream::AppID;
  return app_id_;
}
inline ::dstream::AppID* KillPE::release_app_id() {
  clear_has_app_id();
  ::dstream::AppID* temp = app_id_;
  app_id_ = NULL;
  return temp;
}

// optional .dstream.PEID pe_id = 2;
inline bool KillPE::has_pe_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KillPE::set_has_pe_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KillPE::clear_has_pe_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KillPE::clear_pe_id() {
  if (pe_id_ != NULL) pe_id_->::dstream::PEID::Clear();
  clear_has_pe_id();
}
inline const ::dstream::PEID& KillPE::pe_id() const {
  return pe_id_ != NULL ? *pe_id_ : *default_instance_->pe_id_;
}
inline ::dstream::PEID* KillPE::mutable_pe_id() {
  set_has_pe_id();
  if (pe_id_ == NULL) pe_id_ = new ::dstream::PEID;
  return pe_id_;
}
inline ::dstream::PEID* KillPE::release_pe_id() {
  clear_has_pe_id();
  ::dstream::PEID* temp = pe_id_;
  pe_id_ = NULL;
  return temp;
}

// optional .dstream.BackupPEID backup_pe_id = 3;
inline bool KillPE::has_backup_pe_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KillPE::set_has_backup_pe_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KillPE::clear_has_backup_pe_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KillPE::clear_backup_pe_id() {
  if (backup_pe_id_ != NULL) backup_pe_id_->::dstream::BackupPEID::Clear();
  clear_has_backup_pe_id();
}
inline const ::dstream::BackupPEID& KillPE::backup_pe_id() const {
  return backup_pe_id_ != NULL ? *backup_pe_id_ : *default_instance_->backup_pe_id_;
}
inline ::dstream::BackupPEID* KillPE::mutable_backup_pe_id() {
  set_has_backup_pe_id();
  if (backup_pe_id_ == NULL) backup_pe_id_ = new ::dstream::BackupPEID;
  return backup_pe_id_;
}
inline ::dstream::BackupPEID* KillPE::release_backup_pe_id() {
  clear_has_backup_pe_id();
  ::dstream::BackupPEID* temp = backup_pe_id_;
  backup_pe_id_ = NULL;
  return temp;
}

// optional .dstream.PNID pn_id = 4;
inline bool KillPE::has_pn_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KillPE::set_has_pn_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KillPE::clear_has_pn_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KillPE::clear_pn_id() {
  if (pn_id_ != NULL) pn_id_->::dstream::PNID::Clear();
  clear_has_pn_id();
}
inline const ::dstream::PNID& KillPE::pn_id() const {
  return pn_id_ != NULL ? *pn_id_ : *default_instance_->pn_id_;
}
inline ::dstream::PNID* KillPE::mutable_pn_id() {
  set_has_pn_id();
  if (pn_id_ == NULL) pn_id_ = new ::dstream::PNID;
  return pn_id_;
}
inline ::dstream::PNID* KillPE::release_pn_id() {
  clear_has_pn_id();
  ::dstream::PNID* temp = pn_id_;
  pn_id_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UserOperation

// optional .dstream.UserOperation.Operation type = 1;
inline bool UserOperation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOperation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOperation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOperation::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::dstream::UserOperation_Operation UserOperation::type() const {
  return static_cast< ::dstream::UserOperation_Operation >(type_);
}
inline void UserOperation::set_type(::dstream::UserOperation_Operation value) {
  GOOGLE_DCHECK(::dstream::UserOperation_Operation_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .dstream.User user = 2;
inline bool UserOperation::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOperation::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOperation::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOperation::clear_user() {
  if (user_ != NULL) user_->::dstream::User::Clear();
  clear_has_user();
}
inline const ::dstream::User& UserOperation::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::dstream::User* UserOperation::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::dstream::User;
  return user_;
}
inline ::dstream::User* UserOperation::release_user() {
  clear_has_user();
  ::dstream::User* temp = user_;
  user_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UserOperationReply

// optional .dstream.UserOperationReply.Operation replytype = 1;
inline bool UserOperationReply::has_replytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOperationReply::set_has_replytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOperationReply::clear_has_replytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOperationReply::clear_replytype() {
  replytype_ = 1;
  clear_has_replytype();
}
inline ::dstream::UserOperationReply_Operation UserOperationReply::replytype() const {
  return static_cast< ::dstream::UserOperationReply_Operation >(replytype_);
}
inline void UserOperationReply::set_replytype(::dstream::UserOperationReply_Operation value) {
  GOOGLE_DCHECK(::dstream::UserOperationReply_Operation_IsValid(value));
  set_has_replytype();
  replytype_ = value;
}

// repeated .dstream.User user = 2;
inline int UserOperationReply::user_size() const {
  return user_.size();
}
inline void UserOperationReply::clear_user() {
  user_.Clear();
}
inline const ::dstream::User& UserOperationReply::user(int index) const {
  return user_.Get(index);
}
inline ::dstream::User* UserOperationReply::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::dstream::User* UserOperationReply::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::User >&
UserOperationReply::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::User >*
UserOperationReply::mutable_user() {
  return &user_;
}

// -------------------------------------------------------------------

// StatusRequest

// repeated .dstream.PEID pe_id = 1;
inline int StatusRequest::pe_id_size() const {
  return pe_id_.size();
}
inline void StatusRequest::clear_pe_id() {
  pe_id_.Clear();
}
inline const ::dstream::PEID& StatusRequest::pe_id(int index) const {
  return pe_id_.Get(index);
}
inline ::dstream::PEID* StatusRequest::mutable_pe_id(int index) {
  return pe_id_.Mutable(index);
}
inline ::dstream::PEID* StatusRequest::add_pe_id() {
  return pe_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
StatusRequest::pe_id() const {
  return pe_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
StatusRequest::mutable_pe_id() {
  return &pe_id_;
}

// repeated .dstream.PNID pn_id = 2;
inline int StatusRequest::pn_id_size() const {
  return pn_id_.size();
}
inline void StatusRequest::clear_pn_id() {
  pn_id_.Clear();
}
inline const ::dstream::PNID& StatusRequest::pn_id(int index) const {
  return pn_id_.Get(index);
}
inline ::dstream::PNID* StatusRequest::mutable_pn_id(int index) {
  return pn_id_.Mutable(index);
}
inline ::dstream::PNID* StatusRequest::add_pn_id() {
  return pn_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PNID >&
StatusRequest::pn_id() const {
  return pn_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PNID >*
StatusRequest::mutable_pn_id() {
  return &pn_id_;
}

// -------------------------------------------------------------------

// StatusResponse

// repeated .dstream.BackupPEStatus pe_status_list = 1;
inline int StatusResponse::pe_status_list_size() const {
  return pe_status_list_.size();
}
inline void StatusResponse::clear_pe_status_list() {
  pe_status_list_.Clear();
}
inline const ::dstream::BackupPEStatus& StatusResponse::pe_status_list(int index) const {
  return pe_status_list_.Get(index);
}
inline ::dstream::BackupPEStatus* StatusResponse::mutable_pe_status_list(int index) {
  return pe_status_list_.Mutable(index);
}
inline ::dstream::BackupPEStatus* StatusResponse::add_pe_status_list() {
  return pe_status_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEStatus >&
StatusResponse::pe_status_list() const {
  return pe_status_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::BackupPEStatus >*
StatusResponse::mutable_pe_status_list() {
  return &pe_status_list_;
}

// repeated .dstream.PNReport pn_report_list = 2;
inline int StatusResponse::pn_report_list_size() const {
  return pn_report_list_.size();
}
inline void StatusResponse::clear_pn_report_list() {
  pn_report_list_.Clear();
}
inline const ::dstream::PNReport& StatusResponse::pn_report_list(int index) const {
  return pn_report_list_.Get(index);
}
inline ::dstream::PNReport* StatusResponse::mutable_pn_report_list(int index) {
  return pn_report_list_.Mutable(index);
}
inline ::dstream::PNReport* StatusResponse::add_pn_report_list() {
  return pn_report_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PNReport >&
StatusResponse::pn_report_list() const {
  return pn_report_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PNReport >*
StatusResponse::mutable_pn_report_list() {
  return &pn_report_list_;
}

// -------------------------------------------------------------------

// FlowControlRequest

// optional fixed64 session_id = 1;
inline bool FlowControlRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowControlRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowControlRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowControlRequest::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 FlowControlRequest::session_id() const {
  return session_id_;
}
inline void FlowControlRequest::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .dstream.AppID app_id = 2;
inline bool FlowControlRequest::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowControlRequest::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowControlRequest::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowControlRequest::clear_app_id() {
  if (app_id_ != NULL) app_id_->::dstream::AppID::Clear();
  clear_has_app_id();
}
inline const ::dstream::AppID& FlowControlRequest::app_id() const {
  return app_id_ != NULL ? *app_id_ : *default_instance_->app_id_;
}
inline ::dstream::AppID* FlowControlRequest::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == NULL) app_id_ = new ::dstream::AppID;
  return app_id_;
}
inline ::dstream::AppID* FlowControlRequest::release_app_id() {
  clear_has_app_id();
  ::dstream::AppID* temp = app_id_;
  app_id_ = NULL;
  return temp;
}

// optional string name = 3;
inline bool FlowControlRequest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowControlRequest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowControlRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowControlRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FlowControlRequest::name() const {
  return *name_;
}
inline void FlowControlRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlowControlRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlowControlRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlowControlRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FlowControlRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string processor = 4;
inline bool FlowControlRequest::has_processor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowControlRequest::set_has_processor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowControlRequest::clear_has_processor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowControlRequest::clear_processor() {
  if (processor_ != &::google::protobuf::internal::kEmptyString) {
    processor_->clear();
  }
  clear_has_processor();
}
inline const ::std::string& FlowControlRequest::processor() const {
  return *processor_;
}
inline void FlowControlRequest::set_processor(const ::std::string& value) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(value);
}
inline void FlowControlRequest::set_processor(const char* value) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(value);
}
inline void FlowControlRequest::set_processor(const char* value, size_t size) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlowControlRequest::mutable_processor() {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  return processor_;
}
inline ::std::string* FlowControlRequest::release_processor() {
  clear_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processor_;
    processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 limit = 5;
inline bool FlowControlRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlowControlRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FlowControlRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FlowControlRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 FlowControlRequest::limit() const {
  return limit_;
}
inline void FlowControlRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional .dstream.FlowControlRequest.Operation cmd = 6 [default = GET];
inline bool FlowControlRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FlowControlRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FlowControlRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FlowControlRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::dstream::FlowControlRequest_Operation FlowControlRequest::cmd() const {
  return static_cast< ::dstream::FlowControlRequest_Operation >(cmd_);
}
inline void FlowControlRequest::set_cmd(::dstream::FlowControlRequest_Operation value) {
  GOOGLE_DCHECK(::dstream::FlowControlRequest_Operation_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// -------------------------------------------------------------------

// FlowControlResponse

// optional .dstream.AppID app_id = 1;
inline bool FlowControlResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowControlResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowControlResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowControlResponse::clear_app_id() {
  if (app_id_ != NULL) app_id_->::dstream::AppID::Clear();
  clear_has_app_id();
}
inline const ::dstream::AppID& FlowControlResponse::app_id() const {
  return app_id_ != NULL ? *app_id_ : *default_instance_->app_id_;
}
inline ::dstream::AppID* FlowControlResponse::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == NULL) app_id_ = new ::dstream::AppID;
  return app_id_;
}
inline ::dstream::AppID* FlowControlResponse::release_app_id() {
  clear_has_app_id();
  ::dstream::AppID* temp = app_id_;
  app_id_ = NULL;
  return temp;
}

// optional string name = 2;
inline bool FlowControlResponse::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowControlResponse::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowControlResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowControlResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FlowControlResponse::name() const {
  return *name_;
}
inline void FlowControlResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlowControlResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FlowControlResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlowControlResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FlowControlResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string processor = 3;
inline bool FlowControlResponse::has_processor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowControlResponse::set_has_processor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowControlResponse::clear_has_processor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowControlResponse::clear_processor() {
  if (processor_ != &::google::protobuf::internal::kEmptyString) {
    processor_->clear();
  }
  clear_has_processor();
}
inline const ::std::string& FlowControlResponse::processor() const {
  return *processor_;
}
inline void FlowControlResponse::set_processor(const ::std::string& value) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(value);
}
inline void FlowControlResponse::set_processor(const char* value) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(value);
}
inline void FlowControlResponse::set_processor(const char* value, size_t size) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlowControlResponse::mutable_processor() {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  return processor_;
}
inline ::std::string* FlowControlResponse::release_processor() {
  clear_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processor_;
    processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 limit = 4;
inline bool FlowControlResponse::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowControlResponse::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowControlResponse::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowControlResponse::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 FlowControlResponse::limit() const {
  return limit_;
}
inline void FlowControlResponse::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 result = 5;
inline bool FlowControlResponse::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlowControlResponse::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FlowControlResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FlowControlResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FlowControlResponse::result() const {
  return result_;
}
inline void FlowControlResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UpdateProRequest

// optional fixed64 session_id = 1;
inline bool UpdateProRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateProRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateProRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateProRequest::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 UpdateProRequest::session_id() const {
  return session_id_;
}
inline void UpdateProRequest::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .dstream.Application app = 2;
inline bool UpdateProRequest::has_app() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateProRequest::set_has_app() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateProRequest::clear_has_app() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateProRequest::clear_app() {
  if (app_ != NULL) app_->::dstream::Application::Clear();
  clear_has_app();
}
inline const ::dstream::Application& UpdateProRequest::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::dstream::Application* UpdateProRequest::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::dstream::Application;
  return app_;
}
inline ::dstream::Application* UpdateProRequest::release_app() {
  clear_has_app();
  ::dstream::Application* temp = app_;
  app_ = NULL;
  return temp;
}

// optional string processor_name = 3;
inline bool UpdateProRequest::has_processor_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateProRequest::set_has_processor_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateProRequest::clear_has_processor_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateProRequest::clear_processor_name() {
  if (processor_name_ != &::google::protobuf::internal::kEmptyString) {
    processor_name_->clear();
  }
  clear_has_processor_name();
}
inline const ::std::string& UpdateProRequest::processor_name() const {
  return *processor_name_;
}
inline void UpdateProRequest::set_processor_name(const ::std::string& value) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(value);
}
inline void UpdateProRequest::set_processor_name(const char* value) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(value);
}
inline void UpdateProRequest::set_processor_name(const char* value, size_t size) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateProRequest::mutable_processor_name() {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  return processor_name_;
}
inline ::std::string* UpdateProRequest::release_processor_name() {
  clear_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processor_name_;
    processor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 revision = 4;
inline bool UpdateProRequest::has_revision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateProRequest::set_has_revision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateProRequest::clear_has_revision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateProRequest::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 UpdateProRequest::revision() const {
  return revision_;
}
inline void UpdateProRequest::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// UpdateProResponse

// optional int32 error_num = 1;
inline bool UpdateProResponse::has_error_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateProResponse::set_has_error_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateProResponse::clear_has_error_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateProResponse::clear_error_num() {
  error_num_ = 0;
  clear_has_error_num();
}
inline ::google::protobuf::int32 UpdateProResponse::error_num() const {
  return error_num_;
}
inline void UpdateProResponse::set_error_num(::google::protobuf::int32 value) {
  set_has_error_num();
  error_num_ = value;
}

// optional uint32 revision = 2;
inline bool UpdateProResponse::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateProResponse::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateProResponse::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateProResponse::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 UpdateProResponse::revision() const {
  return revision_;
}
inline void UpdateProResponse::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// UpdateProDone

// optional fixed64 session_id = 1;
inline bool UpdateProDone::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateProDone::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateProDone::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateProDone::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 UpdateProDone::session_id() const {
  return session_id_;
}
inline void UpdateProDone::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional string status = 2;
inline bool UpdateProDone::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateProDone::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateProDone::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateProDone::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& UpdateProDone::status() const {
  return *status_;
}
inline void UpdateProDone::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void UpdateProDone::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void UpdateProDone::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateProDone::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* UpdateProDone::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.Application app = 3;
inline bool UpdateProDone::has_app() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateProDone::set_has_app() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateProDone::clear_has_app() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateProDone::clear_app() {
  if (app_ != NULL) app_->::dstream::Application::Clear();
  clear_has_app();
}
inline const ::dstream::Application& UpdateProDone::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::dstream::Application* UpdateProDone::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::dstream::Application;
  return app_;
}
inline ::dstream::Application* UpdateProDone::release_app() {
  clear_has_app();
  ::dstream::Application* temp = app_;
  app_ = NULL;
  return temp;
}

// optional string processor_name = 4;
inline bool UpdateProDone::has_processor_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateProDone::set_has_processor_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateProDone::clear_has_processor_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateProDone::clear_processor_name() {
  if (processor_name_ != &::google::protobuf::internal::kEmptyString) {
    processor_name_->clear();
  }
  clear_has_processor_name();
}
inline const ::std::string& UpdateProDone::processor_name() const {
  return *processor_name_;
}
inline void UpdateProDone::set_processor_name(const ::std::string& value) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(value);
}
inline void UpdateProDone::set_processor_name(const char* value) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(value);
}
inline void UpdateProDone::set_processor_name(const char* value, size_t size) {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  processor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateProDone::mutable_processor_name() {
  set_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    processor_name_ = new ::std::string;
  }
  return processor_name_;
}
inline ::std::string* UpdateProDone::release_processor_name() {
  clear_has_processor_name();
  if (processor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processor_name_;
    processor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 revision = 5;
inline bool UpdateProDone::has_revision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateProDone::set_has_revision() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateProDone::clear_has_revision() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateProDone::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 UpdateProDone::revision() const {
  return revision_;
}
inline void UpdateProDone::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// BlackListOperationRequest

// repeated .dstream.PEID pe_id = 1;
inline int BlackListOperationRequest::pe_id_size() const {
  return pe_id_.size();
}
inline void BlackListOperationRequest::clear_pe_id() {
  pe_id_.Clear();
}
inline const ::dstream::PEID& BlackListOperationRequest::pe_id(int index) const {
  return pe_id_.Get(index);
}
inline ::dstream::PEID* BlackListOperationRequest::mutable_pe_id(int index) {
  return pe_id_.Mutable(index);
}
inline ::dstream::PEID* BlackListOperationRequest::add_pe_id() {
  return pe_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
BlackListOperationRequest::pe_id() const {
  return pe_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
BlackListOperationRequest::mutable_pe_id() {
  return &pe_id_;
}

// optional .dstream.BlackListOperationRequest.Operation operation = 2;
inline bool BlackListOperationRequest::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlackListOperationRequest::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlackListOperationRequest::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlackListOperationRequest::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::dstream::BlackListOperationRequest_Operation BlackListOperationRequest::operation() const {
  return static_cast< ::dstream::BlackListOperationRequest_Operation >(operation_);
}
inline void BlackListOperationRequest::set_operation(::dstream::BlackListOperationRequest_Operation value) {
  GOOGLE_DCHECK(::dstream::BlackListOperationRequest_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// -------------------------------------------------------------------

// BlackListOperationResponse

// repeated .dstream.PEPNBlackList pe_pn_blacklist = 1;
inline int BlackListOperationResponse::pe_pn_blacklist_size() const {
  return pe_pn_blacklist_.size();
}
inline void BlackListOperationResponse::clear_pe_pn_blacklist() {
  pe_pn_blacklist_.Clear();
}
inline const ::dstream::PEPNBlackList& BlackListOperationResponse::pe_pn_blacklist(int index) const {
  return pe_pn_blacklist_.Get(index);
}
inline ::dstream::PEPNBlackList* BlackListOperationResponse::mutable_pe_pn_blacklist(int index) {
  return pe_pn_blacklist_.Mutable(index);
}
inline ::dstream::PEPNBlackList* BlackListOperationResponse::add_pe_pn_blacklist() {
  return pe_pn_blacklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEPNBlackList >&
BlackListOperationResponse::pe_pn_blacklist() const {
  return pe_pn_blacklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEPNBlackList >*
BlackListOperationResponse::mutable_pe_pn_blacklist() {
  return &pe_pn_blacklist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dstream

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dstream::LoginAck_ErrorCode>() {
  return ::dstream::LoginAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dstream::UpdateTopology_Operation>() {
  return ::dstream::UpdateTopology_Operation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dstream::UserOperation_Operation>() {
  return ::dstream::UserOperation_Operation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dstream::UserOperationReply_Operation>() {
  return ::dstream::UserOperationReply_Operation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dstream::FlowControlRequest_Operation>() {
  return ::dstream::FlowControlRequest_Operation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dstream::BlackListOperationRequest_Operation>() {
  return ::dstream::BlackListOperationRequest_Operation_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pm_5fclient_5frpc_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pub_sub.proto

#ifndef PROTOBUF_pub_5fsub_2eproto__INCLUDED
#define PROTOBUF_pub_5fsub_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "dstream_proto_common.pb.h"
#include "application.pb.h"
// @@protoc_insertion_point(includes)

namespace dstream {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pub_5fsub_2eproto();
void protobuf_AssignDesc_pub_5fsub_2eproto();
void protobuf_ShutdownFile_pub_5fsub_2eproto();

class ImporterTuple;
class PipeID;
class DebugPNRequest;
class DebugPNACK;
class ReadyRequest;
class ReadyACK;
class DoCheckpointRequest;
class DoCheckpointACK;
class UploadCheckpointRequest;
class UploadCheckpointACK;
class ReplayRequest;
class ReplayACK;
class SubscribeRequest;
class SubscribeACK;
class SubscribeImporterRequest;
class SubscribeImporterACK;
class HeartbeatRequest;
class HeartbeatACK;
class TupleMeta;
class Log;
class FetchLogRequest;
class FetchLogACK;
class ForwardLogRequest;
class ForwardLogACK;

// ===================================================================

class ImporterTuple : public ::google::protobuf::Message {
 public:
  ImporterTuple();
  virtual ~ImporterTuple();
  
  ImporterTuple(const ImporterTuple& from);
  
  inline ImporterTuple& operator=(const ImporterTuple& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImporterTuple& default_instance();
  
  void Swap(ImporterTuple* other);
  
  // implements Message ----------------------------------------------
  
  ImporterTuple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImporterTuple& from);
  void MergeFrom(const ImporterTuple& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes raw = 1;
  inline bool has_raw() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 1;
  inline const ::std::string& raw() const;
  inline void set_raw(const ::std::string& value);
  inline void set_raw(const char* value);
  inline void set_raw(const void* value, size_t size);
  inline ::std::string* mutable_raw();
  inline ::std::string* release_raw();
  
  // @@protoc_insertion_point(class_scope:dstream.ImporterTuple)
 private:
  inline void set_has_raw();
  inline void clear_has_raw();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* raw_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ImporterTuple* default_instance_;
};
// -------------------------------------------------------------------

class PipeID : public ::google::protobuf::Message {
 public:
  PipeID();
  virtual ~PipeID();
  
  PipeID(const PipeID& from);
  
  inline PipeID& operator=(const PipeID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PipeID& default_instance();
  
  void Swap(PipeID* other);
  
  // implements Message ----------------------------------------------
  
  PipeID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PipeID& from);
  void MergeFrom(const PipeID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:dstream.PipeID)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static PipeID* default_instance_;
};
// -------------------------------------------------------------------

class DebugPNRequest : public ::google::protobuf::Message {
 public:
  DebugPNRequest();
  virtual ~DebugPNRequest();
  
  DebugPNRequest(const DebugPNRequest& from);
  
  inline DebugPNRequest& operator=(const DebugPNRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugPNRequest& default_instance();
  
  void Swap(DebugPNRequest* other);
  
  // implements Message ----------------------------------------------
  
  DebugPNRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugPNRequest& from);
  void MergeFrom(const DebugPNRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // optional string args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::std::string& args() const;
  inline void set_args(const ::std::string& value);
  inline void set_args(const char* value);
  inline void set_args(const char* value, size_t size);
  inline ::std::string* mutable_args();
  inline ::std::string* release_args();
  
  // @@protoc_insertion_point(class_scope:dstream.DebugPNRequest)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_args();
  inline void clear_has_args();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  ::std::string* args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static DebugPNRequest* default_instance_;
};
// -------------------------------------------------------------------

class DebugPNACK : public ::google::protobuf::Message {
 public:
  DebugPNACK();
  virtual ~DebugPNACK();
  
  DebugPNACK(const DebugPNACK& from);
  
  inline DebugPNACK& operator=(const DebugPNACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugPNACK& default_instance();
  
  void Swap(DebugPNACK* other);
  
  // implements Message ----------------------------------------------
  
  DebugPNACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugPNACK& from);
  void MergeFrom(const DebugPNACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string debug_info = 1;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 1;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.DebugPNACK)
 private:
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static DebugPNACK* default_instance_;
};
// -------------------------------------------------------------------

class ReadyRequest : public ::google::protobuf::Message {
 public:
  ReadyRequest();
  virtual ~ReadyRequest();
  
  ReadyRequest(const ReadyRequest& from);
  
  inline ReadyRequest& operator=(const ReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyRequest& default_instance();
  
  void Swap(ReadyRequest* other);
  
  // implements Message ----------------------------------------------
  
  ReadyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadyRequest& from);
  void MergeFrom(const ReadyRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // @@protoc_insertion_point(class_scope:dstream.ReadyRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ReadyRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadyACK : public ::google::protobuf::Message {
 public:
  ReadyACK();
  virtual ~ReadyACK();
  
  ReadyACK(const ReadyACK& from);
  
  inline ReadyACK& operator=(const ReadyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyACK& default_instance();
  
  void Swap(ReadyACK* other);
  
  // implements Message ----------------------------------------------
  
  ReadyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadyACK& from);
  void MergeFrom(const ReadyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.ReadyACK)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ReadyACK* default_instance_;
};
// -------------------------------------------------------------------

class DoCheckpointRequest : public ::google::protobuf::Message {
 public:
  DoCheckpointRequest();
  virtual ~DoCheckpointRequest();
  
  DoCheckpointRequest(const DoCheckpointRequest& from);
  
  inline DoCheckpointRequest& operator=(const DoCheckpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DoCheckpointRequest& default_instance();
  
  void Swap(DoCheckpointRequest* other);
  
  // implements Message ----------------------------------------------
  
  DoCheckpointRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoCheckpointRequest& from);
  void MergeFrom(const DoCheckpointRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // @@protoc_insertion_point(class_scope:dstream.DoCheckpointRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static DoCheckpointRequest* default_instance_;
};
// -------------------------------------------------------------------

class DoCheckpointACK : public ::google::protobuf::Message {
 public:
  DoCheckpointACK();
  virtual ~DoCheckpointACK();
  
  DoCheckpointACK(const DoCheckpointACK& from);
  
  inline DoCheckpointACK& operator=(const DoCheckpointACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DoCheckpointACK& default_instance();
  
  void Swap(DoCheckpointACK* other);
  
  // implements Message ----------------------------------------------
  
  DoCheckpointACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoCheckpointACK& from);
  void MergeFrom(const DoCheckpointACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:dstream.DoCheckpointACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static DoCheckpointACK* default_instance_;
};
// -------------------------------------------------------------------

class UploadCheckpointRequest : public ::google::protobuf::Message {
 public:
  UploadCheckpointRequest();
  virtual ~UploadCheckpointRequest();
  
  UploadCheckpointRequest(const UploadCheckpointRequest& from);
  
  inline UploadCheckpointRequest& operator=(const UploadCheckpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadCheckpointRequest& default_instance();
  
  void Swap(UploadCheckpointRequest* other);
  
  // implements Message ----------------------------------------------
  
  UploadCheckpointRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadCheckpointRequest& from);
  void MergeFrom(const UploadCheckpointRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // optional string chkpdir = 2;
  inline bool has_chkpdir() const;
  inline void clear_chkpdir();
  static const int kChkpdirFieldNumber = 2;
  inline const ::std::string& chkpdir() const;
  inline void set_chkpdir(const ::std::string& value);
  inline void set_chkpdir(const char* value);
  inline void set_chkpdir(const char* value, size_t size);
  inline ::std::string* mutable_chkpdir();
  inline ::std::string* release_chkpdir();
  
  // @@protoc_insertion_point(class_scope:dstream.UploadCheckpointRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  inline void set_has_chkpdir();
  inline void clear_has_chkpdir();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  ::std::string* chkpdir_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static UploadCheckpointRequest* default_instance_;
};
// -------------------------------------------------------------------

class UploadCheckpointACK : public ::google::protobuf::Message {
 public:
  UploadCheckpointACK();
  virtual ~UploadCheckpointACK();
  
  UploadCheckpointACK(const UploadCheckpointACK& from);
  
  inline UploadCheckpointACK& operator=(const UploadCheckpointACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadCheckpointACK& default_instance();
  
  void Swap(UploadCheckpointACK* other);
  
  // implements Message ----------------------------------------------
  
  UploadCheckpointACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadCheckpointACK& from);
  void MergeFrom(const UploadCheckpointACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:dstream.UploadCheckpointACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static UploadCheckpointACK* default_instance_;
};
// -------------------------------------------------------------------

class ReplayRequest : public ::google::protobuf::Message {
 public:
  ReplayRequest();
  virtual ~ReplayRequest();
  
  ReplayRequest(const ReplayRequest& from);
  
  inline ReplayRequest& operator=(const ReplayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplayRequest& default_instance();
  
  void Swap(ReplayRequest* other);
  
  // implements Message ----------------------------------------------
  
  ReplayRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplayRequest& from);
  void MergeFrom(const ReplayRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // optional .dstream.PipeID pipeid = 2;
  inline bool has_pipeid() const;
  inline void clear_pipeid();
  static const int kPipeidFieldNumber = 2;
  inline const ::dstream::PipeID& pipeid() const;
  inline ::dstream::PipeID* mutable_pipeid();
  inline ::dstream::PipeID* release_pipeid();
  
  // @@protoc_insertion_point(class_scope:dstream.ReplayRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  inline void set_has_pipeid();
  inline void clear_has_pipeid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  ::dstream::PipeID* pipeid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ReplayRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReplayACK : public ::google::protobuf::Message {
 public:
  ReplayACK();
  virtual ~ReplayACK();
  
  ReplayACK(const ReplayACK& from);
  
  inline ReplayACK& operator=(const ReplayACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplayACK& default_instance();
  
  void Swap(ReplayACK* other);
  
  // implements Message ----------------------------------------------
  
  ReplayACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplayACK& from);
  void MergeFrom(const ReplayACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:dstream.ReplayACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ReplayACK* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeRequest : public ::google::protobuf::Message {
 public:
  SubscribeRequest();
  virtual ~SubscribeRequest();
  
  SubscribeRequest(const SubscribeRequest& from);
  
  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeRequest& default_instance();
  
  void Swap(SubscribeRequest* other);
  
  // implements Message ----------------------------------------------
  
  SubscribeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeRequest& from);
  void MergeFrom(const SubscribeRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // repeated .dstream.PEID peids = 2;
  inline int peids_size() const;
  inline void clear_peids();
  static const int kPeidsFieldNumber = 2;
  inline const ::dstream::PEID& peids(int index) const;
  inline ::dstream::PEID* mutable_peids(int index);
  inline ::dstream::PEID* add_peids();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
      peids() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
      mutable_peids();
  
  // repeated .dstream.PipeID pipeids = 3;
  inline int pipeids_size() const;
  inline void clear_pipeids();
  static const int kPipeidsFieldNumber = 3;
  inline const ::dstream::PipeID& pipeids(int index) const;
  inline ::dstream::PipeID* mutable_pipeids(int index);
  inline ::dstream::PipeID* add_pipeids();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >&
      pipeids() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >*
      mutable_pipeids();
  
  // optional string peid_time = 4;
  inline bool has_peid_time() const;
  inline void clear_peid_time();
  static const int kPeidTimeFieldNumber = 4;
  inline const ::std::string& peid_time() const;
  inline void set_peid_time(const ::std::string& value);
  inline void set_peid_time(const char* value);
  inline void set_peid_time(const char* value, size_t size);
  inline ::std::string* mutable_peid_time();
  inline ::std::string* release_peid_time();
  
  // optional string debug_info = 5;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 5;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.SubscribeRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  inline void set_has_peid_time();
  inline void clear_has_peid_time();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  ::google::protobuf::RepeatedPtrField< ::dstream::PEID > peids_;
  ::google::protobuf::RepeatedPtrField< ::dstream::PipeID > pipeids_;
  ::std::string* peid_time_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static SubscribeRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeACK : public ::google::protobuf::Message {
 public:
  SubscribeACK();
  virtual ~SubscribeACK();
  
  SubscribeACK(const SubscribeACK& from);
  
  inline SubscribeACK& operator=(const SubscribeACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeACK& default_instance();
  
  void Swap(SubscribeACK* other);
  
  // implements Message ----------------------------------------------
  
  SubscribeACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeACK& from);
  void MergeFrom(const SubscribeACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.PEID peid = 1;
  inline int peid_size() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid(int index) const;
  inline ::dstream::PEID* mutable_peid(int index);
  inline ::dstream::PEID* add_peid();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
      peid() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
      mutable_peid();
  
  // repeated fixed32 res = 2;
  inline int res_size() const;
  inline void clear_res();
  static const int kResFieldNumber = 2;
  inline ::google::protobuf::uint32 res(int index) const;
  inline void set_res(int index, ::google::protobuf::uint32 value);
  inline void add_res(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      res() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_res();
  
  // optional string peid_time = 3;
  inline bool has_peid_time() const;
  inline void clear_peid_time();
  static const int kPeidTimeFieldNumber = 3;
  inline const ::std::string& peid_time() const;
  inline void set_peid_time(const ::std::string& value);
  inline void set_peid_time(const char* value);
  inline void set_peid_time(const char* value, size_t size);
  inline ::std::string* mutable_peid_time();
  inline ::std::string* release_peid_time();
  
  // optional string debug_info = 4;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 4;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.SubscribeACK)
 private:
  inline void set_has_peid_time();
  inline void clear_has_peid_time();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::PEID > peid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > res_;
  ::std::string* peid_time_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static SubscribeACK* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeImporterRequest : public ::google::protobuf::Message {
 public:
  SubscribeImporterRequest();
  virtual ~SubscribeImporterRequest();
  
  SubscribeImporterRequest(const SubscribeImporterRequest& from);
  
  inline SubscribeImporterRequest& operator=(const SubscribeImporterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImporterRequest& default_instance();
  
  void Swap(SubscribeImporterRequest* other);
  
  // implements Message ----------------------------------------------
  
  SubscribeImporterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeImporterRequest& from);
  void MergeFrom(const SubscribeImporterRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();
  
  // repeated .dstream.PipeID pipeids = 2;
  inline int pipeids_size() const;
  inline void clear_pipeids();
  static const int kPipeidsFieldNumber = 2;
  inline const ::dstream::PipeID& pipeids(int index) const;
  inline ::dstream::PipeID* mutable_pipeids(int index);
  inline ::dstream::PipeID* add_pipeids();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >&
      pipeids() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >*
      mutable_pipeids();
  
  // optional string debug_info = 3;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 3;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.SubscribeImporterRequest)
 private:
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::google::protobuf::RepeatedPtrField< ::dstream::PipeID > pipeids_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static SubscribeImporterRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeImporterACK : public ::google::protobuf::Message {
 public:
  SubscribeImporterACK();
  virtual ~SubscribeImporterACK();
  
  SubscribeImporterACK(const SubscribeImporterACK& from);
  
  inline SubscribeImporterACK& operator=(const SubscribeImporterACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImporterACK& default_instance();
  
  void Swap(SubscribeImporterACK* other);
  
  // implements Message ----------------------------------------------
  
  SubscribeImporterACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeImporterACK& from);
  void MergeFrom(const SubscribeImporterACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string debug_info = 1;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 1;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.SubscribeImporterACK)
 private:
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static SubscribeImporterACK* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();
  
  HeartbeatRequest(const HeartbeatRequest& from);
  
  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();
  
  void Swap(HeartbeatRequest* other);
  
  // implements Message ----------------------------------------------
  
  HeartbeatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // repeated string metric_name = 2;
  inline int metric_name_size() const;
  inline void clear_metric_name();
  static const int kMetricNameFieldNumber = 2;
  inline const ::std::string& metric_name(int index) const;
  inline ::std::string* mutable_metric_name(int index);
  inline void set_metric_name(int index, const ::std::string& value);
  inline void set_metric_name(int index, const char* value);
  inline void set_metric_name(int index, const char* value, size_t size);
  inline ::std::string* add_metric_name();
  inline void add_metric_name(const ::std::string& value);
  inline void add_metric_name(const char* value);
  inline void add_metric_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& metric_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_metric_name();
  
  // repeated string metric_value = 3;
  inline int metric_value_size() const;
  inline void clear_metric_value();
  static const int kMetricValueFieldNumber = 3;
  inline const ::std::string& metric_value(int index) const;
  inline ::std::string* mutable_metric_value(int index);
  inline void set_metric_value(int index, const ::std::string& value);
  inline void set_metric_value(int index, const char* value);
  inline void set_metric_value(int index, const char* value, size_t size);
  inline ::std::string* add_metric_value();
  inline void add_metric_value(const ::std::string& value);
  inline void add_metric_value(const char* value);
  inline void add_metric_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& metric_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_metric_value();
  
  // optional string debug_info = 4;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 4;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.HeartbeatRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> metric_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> metric_value_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static HeartbeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatACK : public ::google::protobuf::Message {
 public:
  HeartbeatACK();
  virtual ~HeartbeatACK();
  
  HeartbeatACK(const HeartbeatACK& from);
  
  inline HeartbeatACK& operator=(const HeartbeatACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatACK& default_instance();
  
  void Swap(HeartbeatACK* other);
  
  // implements Message ----------------------------------------------
  
  HeartbeatACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatACK& from);
  void MergeFrom(const HeartbeatACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string debug_info = 1;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 1;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // optional .dstream.FlowControl flow_control = 2;
  inline bool has_flow_control() const;
  inline void clear_flow_control();
  static const int kFlowControlFieldNumber = 2;
  inline const ::dstream::FlowControl& flow_control() const;
  inline ::dstream::FlowControl* mutable_flow_control();
  inline ::dstream::FlowControl* release_flow_control();
  
  // @@protoc_insertion_point(class_scope:dstream.HeartbeatACK)
 private:
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  inline void set_has_flow_control();
  inline void clear_has_flow_control();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* debug_info_;
  ::dstream::FlowControl* flow_control_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static HeartbeatACK* default_instance_;
};
// -------------------------------------------------------------------

class TupleMeta : public ::google::protobuf::Message {
 public:
  TupleMeta();
  virtual ~TupleMeta();
  
  TupleMeta(const TupleMeta& from);
  
  inline TupleMeta& operator=(const TupleMeta& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TupleMeta& default_instance();
  
  void Swap(TupleMeta* other);
  
  // implements Message ----------------------------------------------
  
  TupleMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TupleMeta& from);
  void MergeFrom(const TupleMeta& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 hash_code = 1;
  inline bool has_hash_code() const;
  inline void clear_hash_code();
  static const int kHashCodeFieldNumber = 1;
  inline ::google::protobuf::uint64 hash_code() const;
  inline void set_hash_code(::google::protobuf::uint64 value);
  
  // optional string tags = 2;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 2;
  inline const ::std::string& tags() const;
  inline void set_tags(const ::std::string& value);
  inline void set_tags(const char* value);
  inline void set_tags(const char* value, size_t size);
  inline ::std::string* mutable_tags();
  inline ::std::string* release_tags();
  
  // @@protoc_insertion_point(class_scope:dstream.TupleMeta)
 private:
  inline void set_has_hash_code();
  inline void clear_has_hash_code();
  inline void set_has_tags();
  inline void clear_has_tags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 hash_code_;
  ::std::string* tags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static TupleMeta* default_instance_;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message {
 public:
  Log();
  virtual ~Log();
  
  Log(const Log& from);
  
  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();
  
  void Swap(Log* other);
  
  // implements Message ----------------------------------------------
  
  Log* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID upstream_peid = 1;
  inline bool has_upstream_peid() const;
  inline void clear_upstream_peid();
  static const int kUpstreamPeidFieldNumber = 1;
  inline const ::dstream::PEID& upstream_peid() const;
  inline ::dstream::PEID* mutable_upstream_peid();
  inline ::dstream::PEID* release_upstream_peid();
  
  // optional .dstream.PipeID upstream_pipeid = 2;
  inline bool has_upstream_pipeid() const;
  inline void clear_upstream_pipeid();
  static const int kUpstreamPipeidFieldNumber = 2;
  inline const ::dstream::PipeID& upstream_pipeid() const;
  inline ::dstream::PipeID* mutable_upstream_pipeid();
  inline ::dstream::PipeID* release_upstream_pipeid();
  
  // optional .dstream.PipeID pipeid = 11;
  inline bool has_pipeid() const;
  inline void clear_pipeid();
  static const int kPipeidFieldNumber = 11;
  inline const ::dstream::PipeID& pipeid() const;
  inline ::dstream::PipeID* mutable_pipeid();
  inline ::dstream::PipeID* release_pipeid();
  
  // optional .dstream.PEID src_peid = 21;
  inline bool has_src_peid() const;
  inline void clear_src_peid();
  static const int kSrcPeidFieldNumber = 21;
  inline const ::dstream::PEID& src_peid() const;
  inline ::dstream::PEID* mutable_src_peid();
  inline ::dstream::PEID* release_src_peid();
  
  // optional .dstream.PEID dst_peid = 22;
  inline bool has_dst_peid() const;
  inline void clear_dst_peid();
  static const int kDstPeidFieldNumber = 22;
  inline const ::dstream::PEID& dst_peid() const;
  inline ::dstream::PEID* mutable_dst_peid();
  inline ::dstream::PEID* release_dst_peid();
  
  // repeated .dstream.TupleMeta tuples_meta = 31;
  inline int tuples_meta_size() const;
  inline void clear_tuples_meta();
  static const int kTuplesMetaFieldNumber = 31;
  inline const ::dstream::TupleMeta& tuples_meta(int index) const;
  inline ::dstream::TupleMeta* mutable_tuples_meta(int index);
  inline ::dstream::TupleMeta* add_tuples_meta();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::TupleMeta >&
      tuples_meta() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::TupleMeta >*
      mutable_tuples_meta();
  
  // repeated bytes tuples = 32;
  inline int tuples_size() const;
  inline void clear_tuples();
  static const int kTuplesFieldNumber = 32;
  inline const ::std::string& tuples(int index) const;
  inline ::std::string* mutable_tuples(int index);
  inline void set_tuples(int index, const ::std::string& value);
  inline void set_tuples(int index, const char* value);
  inline void set_tuples(int index, const void* value, size_t size);
  inline ::std::string* add_tuples();
  inline void add_tuples(const ::std::string& value);
  inline void add_tuples(const char* value);
  inline void add_tuples(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tuples() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tuples();
  
  // optional bytes patch = 33;
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 33;
  inline const ::std::string& patch() const;
  inline void set_patch(const ::std::string& value);
  inline void set_patch(const char* value);
  inline void set_patch(const void* value, size_t size);
  inline ::std::string* mutable_patch();
  inline ::std::string* release_patch();
  
  // required string debug_info = 34;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 34;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.Log)
 private:
  inline void set_has_upstream_peid();
  inline void clear_has_upstream_peid();
  inline void set_has_upstream_pipeid();
  inline void clear_has_upstream_pipeid();
  inline void set_has_pipeid();
  inline void clear_has_pipeid();
  inline void set_has_src_peid();
  inline void clear_has_src_peid();
  inline void set_has_dst_peid();
  inline void clear_has_dst_peid();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* upstream_peid_;
  ::dstream::PipeID* upstream_pipeid_;
  ::dstream::PipeID* pipeid_;
  ::dstream::PEID* src_peid_;
  ::dstream::PEID* dst_peid_;
  ::google::protobuf::RepeatedPtrField< ::dstream::TupleMeta > tuples_meta_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tuples_;
  ::std::string* patch_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static Log* default_instance_;
};
// -------------------------------------------------------------------

class FetchLogRequest : public ::google::protobuf::Message {
 public:
  FetchLogRequest();
  virtual ~FetchLogRequest();
  
  FetchLogRequest(const FetchLogRequest& from);
  
  inline FetchLogRequest& operator=(const FetchLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchLogRequest& default_instance();
  
  void Swap(FetchLogRequest* other);
  
  // implements Message ----------------------------------------------
  
  FetchLogRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchLogRequest& from);
  void MergeFrom(const FetchLogRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // optional bool replay_mode = 2;
  inline bool has_replay_mode() const;
  inline void clear_replay_mode();
  static const int kReplayModeFieldNumber = 2;
  inline bool replay_mode() const;
  inline void set_replay_mode(bool value);
  
  // optional string debug_info = 3;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 3;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.FetchLogRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  inline void set_has_replay_mode();
  inline void clear_has_replay_mode();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  ::std::string* debug_info_;
  bool replay_mode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static FetchLogRequest* default_instance_;
};
// -------------------------------------------------------------------

class FetchLogACK : public ::google::protobuf::Message {
 public:
  FetchLogACK();
  virtual ~FetchLogACK();
  
  FetchLogACK(const FetchLogACK& from);
  
  inline FetchLogACK& operator=(const FetchLogACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchLogACK& default_instance();
  
  void Swap(FetchLogACK* other);
  
  // implements Message ----------------------------------------------
  
  FetchLogACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchLogACK& from);
  void MergeFrom(const FetchLogACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 delay_ms = 1;
  inline bool has_delay_ms() const;
  inline void clear_delay_ms();
  static const int kDelayMsFieldNumber = 1;
  inline ::google::protobuf::uint64 delay_ms() const;
  inline void set_delay_ms(::google::protobuf::uint64 value);
  
  // optional .dstream.Log log = 2;
  inline bool has_log() const;
  inline void clear_log();
  static const int kLogFieldNumber = 2;
  inline const ::dstream::Log& log() const;
  inline ::dstream::Log* mutable_log();
  inline ::dstream::Log* release_log();
  
  // optional bool end_replay = 3;
  inline bool has_end_replay() const;
  inline void clear_end_replay();
  static const int kEndReplayFieldNumber = 3;
  inline bool end_replay() const;
  inline void set_end_replay(bool value);
  
  // optional fixed32 res = 4;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 4;
  inline ::google::protobuf::uint32 res() const;
  inline void set_res(::google::protobuf::uint32 value);
  
  // optional string debug_info = 5;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 5;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.FetchLogACK)
 private:
  inline void set_has_delay_ms();
  inline void clear_has_delay_ms();
  inline void set_has_log();
  inline void clear_has_log();
  inline void set_has_end_replay();
  inline void clear_has_end_replay();
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 delay_ms_;
  ::dstream::Log* log_;
  bool end_replay_;
  ::google::protobuf::uint32 res_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static FetchLogACK* default_instance_;
};
// -------------------------------------------------------------------

class ForwardLogRequest : public ::google::protobuf::Message {
 public:
  ForwardLogRequest();
  virtual ~ForwardLogRequest();
  
  ForwardLogRequest(const ForwardLogRequest& from);
  
  inline ForwardLogRequest& operator=(const ForwardLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForwardLogRequest& default_instance();
  
  void Swap(ForwardLogRequest* other);
  
  // implements Message ----------------------------------------------
  
  ForwardLogRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForwardLogRequest& from);
  void MergeFrom(const ForwardLogRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PEID peid = 1;
  inline bool has_peid() const;
  inline void clear_peid();
  static const int kPeidFieldNumber = 1;
  inline const ::dstream::PEID& peid() const;
  inline ::dstream::PEID* mutable_peid();
  inline ::dstream::PEID* release_peid();
  
  // optional .dstream.Log log = 2;
  inline bool has_log() const;
  inline void clear_log();
  static const int kLogFieldNumber = 2;
  inline const ::dstream::Log& log() const;
  inline ::dstream::Log* mutable_log();
  inline ::dstream::Log* release_log();
  
  // optional string debug_info = 3;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 3;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // @@protoc_insertion_point(class_scope:dstream.ForwardLogRequest)
 private:
  inline void set_has_peid();
  inline void clear_has_peid();
  inline void set_has_log();
  inline void clear_has_log();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PEID* peid_;
  ::dstream::Log* log_;
  ::std::string* debug_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ForwardLogRequest* default_instance_;
};
// -------------------------------------------------------------------

class ForwardLogACK : public ::google::protobuf::Message {
 public:
  ForwardLogACK();
  virtual ~ForwardLogACK();
  
  ForwardLogACK(const ForwardLogACK& from);
  
  inline ForwardLogACK& operator=(const ForwardLogACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForwardLogACK& default_instance();
  
  void Swap(ForwardLogACK* other);
  
  // implements Message ----------------------------------------------
  
  ForwardLogACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForwardLogACK& from);
  void MergeFrom(const ForwardLogACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string debug_info = 1;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 1;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  
  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.ForwardLogACK)
 private:
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* debug_info_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pub_5fsub_2eproto();
  friend void protobuf_AssignDesc_pub_5fsub_2eproto();
  friend void protobuf_ShutdownFile_pub_5fsub_2eproto();
  
  void InitAsDefaultInstance();
  static ForwardLogACK* default_instance_;
};
// ===================================================================


// ===================================================================

// ImporterTuple

// optional bytes raw = 1;
inline bool ImporterTuple::has_raw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImporterTuple::set_has_raw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImporterTuple::clear_has_raw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImporterTuple::clear_raw() {
  if (raw_ != &::google::protobuf::internal::kEmptyString) {
    raw_->clear();
  }
  clear_has_raw();
}
inline const ::std::string& ImporterTuple::raw() const {
  return *raw_;
}
inline void ImporterTuple::set_raw(const ::std::string& value) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::kEmptyString) {
    raw_ = new ::std::string;
  }
  raw_->assign(value);
}
inline void ImporterTuple::set_raw(const char* value) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::kEmptyString) {
    raw_ = new ::std::string;
  }
  raw_->assign(value);
}
inline void ImporterTuple::set_raw(const void* value, size_t size) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::kEmptyString) {
    raw_ = new ::std::string;
  }
  raw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImporterTuple::mutable_raw() {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::kEmptyString) {
    raw_ = new ::std::string;
  }
  return raw_;
}
inline ::std::string* ImporterTuple::release_raw() {
  clear_has_raw();
  if (raw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raw_;
    raw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PipeID

// optional fixed64 id = 1;
inline bool PipeID::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PipeID::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PipeID::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PipeID::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 PipeID::id() const {
  return id_;
}
inline void PipeID::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// DebugPNRequest

// optional string cmd = 1;
inline bool DebugPNRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugPNRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugPNRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugPNRequest::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& DebugPNRequest::cmd() const {
  return *cmd_;
}
inline void DebugPNRequest::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void DebugPNRequest::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void DebugPNRequest::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugPNRequest::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* DebugPNRequest::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string args = 2;
inline bool DebugPNRequest::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugPNRequest::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugPNRequest::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugPNRequest::clear_args() {
  if (args_ != &::google::protobuf::internal::kEmptyString) {
    args_->clear();
  }
  clear_has_args();
}
inline const ::std::string& DebugPNRequest::args() const {
  return *args_;
}
inline void DebugPNRequest::set_args(const ::std::string& value) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::kEmptyString) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void DebugPNRequest::set_args(const char* value) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::kEmptyString) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void DebugPNRequest::set_args(const char* value, size_t size) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::kEmptyString) {
    args_ = new ::std::string;
  }
  args_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugPNRequest::mutable_args() {
  set_has_args();
  if (args_ == &::google::protobuf::internal::kEmptyString) {
    args_ = new ::std::string;
  }
  return args_;
}
inline ::std::string* DebugPNRequest::release_args() {
  clear_has_args();
  if (args_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = args_;
    args_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DebugPNACK

// optional string debug_info = 1;
inline bool DebugPNACK::has_debug_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugPNACK::set_has_debug_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugPNACK::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugPNACK::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& DebugPNACK::debug_info() const {
  return *debug_info_;
}
inline void DebugPNACK::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void DebugPNACK::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void DebugPNACK::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugPNACK::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* DebugPNACK::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReadyRequest

// optional .dstream.PEID peid = 1;
inline bool ReadyRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadyRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadyRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadyRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& ReadyRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* ReadyRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* ReadyRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ReadyACK

// optional int32 status = 1;
inline bool ReadyACK::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadyACK::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadyACK::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadyACK::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ReadyACK::status() const {
  return status_;
}
inline void ReadyACK::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// DoCheckpointRequest

// optional .dstream.PEID peid = 1;
inline bool DoCheckpointRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoCheckpointRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoCheckpointRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoCheckpointRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& DoCheckpointRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* DoCheckpointRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* DoCheckpointRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DoCheckpointACK

// -------------------------------------------------------------------

// UploadCheckpointRequest

// optional .dstream.PEID peid = 1;
inline bool UploadCheckpointRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadCheckpointRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadCheckpointRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadCheckpointRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& UploadCheckpointRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* UploadCheckpointRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* UploadCheckpointRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// optional string chkpdir = 2;
inline bool UploadCheckpointRequest::has_chkpdir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadCheckpointRequest::set_has_chkpdir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadCheckpointRequest::clear_has_chkpdir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadCheckpointRequest::clear_chkpdir() {
  if (chkpdir_ != &::google::protobuf::internal::kEmptyString) {
    chkpdir_->clear();
  }
  clear_has_chkpdir();
}
inline const ::std::string& UploadCheckpointRequest::chkpdir() const {
  return *chkpdir_;
}
inline void UploadCheckpointRequest::set_chkpdir(const ::std::string& value) {
  set_has_chkpdir();
  if (chkpdir_ == &::google::protobuf::internal::kEmptyString) {
    chkpdir_ = new ::std::string;
  }
  chkpdir_->assign(value);
}
inline void UploadCheckpointRequest::set_chkpdir(const char* value) {
  set_has_chkpdir();
  if (chkpdir_ == &::google::protobuf::internal::kEmptyString) {
    chkpdir_ = new ::std::string;
  }
  chkpdir_->assign(value);
}
inline void UploadCheckpointRequest::set_chkpdir(const char* value, size_t size) {
  set_has_chkpdir();
  if (chkpdir_ == &::google::protobuf::internal::kEmptyString) {
    chkpdir_ = new ::std::string;
  }
  chkpdir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadCheckpointRequest::mutable_chkpdir() {
  set_has_chkpdir();
  if (chkpdir_ == &::google::protobuf::internal::kEmptyString) {
    chkpdir_ = new ::std::string;
  }
  return chkpdir_;
}
inline ::std::string* UploadCheckpointRequest::release_chkpdir() {
  clear_has_chkpdir();
  if (chkpdir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chkpdir_;
    chkpdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UploadCheckpointACK

// -------------------------------------------------------------------

// ReplayRequest

// optional .dstream.PEID peid = 1;
inline bool ReplayRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplayRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplayRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplayRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& ReplayRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* ReplayRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* ReplayRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// optional .dstream.PipeID pipeid = 2;
inline bool ReplayRequest::has_pipeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplayRequest::set_has_pipeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplayRequest::clear_has_pipeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplayRequest::clear_pipeid() {
  if (pipeid_ != NULL) pipeid_->::dstream::PipeID::Clear();
  clear_has_pipeid();
}
inline const ::dstream::PipeID& ReplayRequest::pipeid() const {
  return pipeid_ != NULL ? *pipeid_ : *default_instance_->pipeid_;
}
inline ::dstream::PipeID* ReplayRequest::mutable_pipeid() {
  set_has_pipeid();
  if (pipeid_ == NULL) pipeid_ = new ::dstream::PipeID;
  return pipeid_;
}
inline ::dstream::PipeID* ReplayRequest::release_pipeid() {
  clear_has_pipeid();
  ::dstream::PipeID* temp = pipeid_;
  pipeid_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ReplayACK

// -------------------------------------------------------------------

// SubscribeRequest

// optional .dstream.PEID peid = 1;
inline bool SubscribeRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& SubscribeRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* SubscribeRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* SubscribeRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// repeated .dstream.PEID peids = 2;
inline int SubscribeRequest::peids_size() const {
  return peids_.size();
}
inline void SubscribeRequest::clear_peids() {
  peids_.Clear();
}
inline const ::dstream::PEID& SubscribeRequest::peids(int index) const {
  return peids_.Get(index);
}
inline ::dstream::PEID* SubscribeRequest::mutable_peids(int index) {
  return peids_.Mutable(index);
}
inline ::dstream::PEID* SubscribeRequest::add_peids() {
  return peids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
SubscribeRequest::peids() const {
  return peids_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
SubscribeRequest::mutable_peids() {
  return &peids_;
}

// repeated .dstream.PipeID pipeids = 3;
inline int SubscribeRequest::pipeids_size() const {
  return pipeids_.size();
}
inline void SubscribeRequest::clear_pipeids() {
  pipeids_.Clear();
}
inline const ::dstream::PipeID& SubscribeRequest::pipeids(int index) const {
  return pipeids_.Get(index);
}
inline ::dstream::PipeID* SubscribeRequest::mutable_pipeids(int index) {
  return pipeids_.Mutable(index);
}
inline ::dstream::PipeID* SubscribeRequest::add_pipeids() {
  return pipeids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >&
SubscribeRequest::pipeids() const {
  return pipeids_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >*
SubscribeRequest::mutable_pipeids() {
  return &pipeids_;
}

// optional string peid_time = 4;
inline bool SubscribeRequest::has_peid_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubscribeRequest::set_has_peid_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubscribeRequest::clear_has_peid_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubscribeRequest::clear_peid_time() {
  if (peid_time_ != &::google::protobuf::internal::kEmptyString) {
    peid_time_->clear();
  }
  clear_has_peid_time();
}
inline const ::std::string& SubscribeRequest::peid_time() const {
  return *peid_time_;
}
inline void SubscribeRequest::set_peid_time(const ::std::string& value) {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  peid_time_->assign(value);
}
inline void SubscribeRequest::set_peid_time(const char* value) {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  peid_time_->assign(value);
}
inline void SubscribeRequest::set_peid_time(const char* value, size_t size) {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  peid_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeRequest::mutable_peid_time() {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  return peid_time_;
}
inline ::std::string* SubscribeRequest::release_peid_time() {
  clear_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peid_time_;
    peid_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string debug_info = 5;
inline bool SubscribeRequest::has_debug_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubscribeRequest::set_has_debug_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubscribeRequest::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubscribeRequest::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& SubscribeRequest::debug_info() const {
  return *debug_info_;
}
inline void SubscribeRequest::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeRequest::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeRequest::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeRequest::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* SubscribeRequest::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SubscribeACK

// repeated .dstream.PEID peid = 1;
inline int SubscribeACK::peid_size() const {
  return peid_.size();
}
inline void SubscribeACK::clear_peid() {
  peid_.Clear();
}
inline const ::dstream::PEID& SubscribeACK::peid(int index) const {
  return peid_.Get(index);
}
inline ::dstream::PEID* SubscribeACK::mutable_peid(int index) {
  return peid_.Mutable(index);
}
inline ::dstream::PEID* SubscribeACK::add_peid() {
  return peid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEID >&
SubscribeACK::peid() const {
  return peid_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEID >*
SubscribeACK::mutable_peid() {
  return &peid_;
}

// repeated fixed32 res = 2;
inline int SubscribeACK::res_size() const {
  return res_.size();
}
inline void SubscribeACK::clear_res() {
  res_.Clear();
}
inline ::google::protobuf::uint32 SubscribeACK::res(int index) const {
  return res_.Get(index);
}
inline void SubscribeACK::set_res(int index, ::google::protobuf::uint32 value) {
  res_.Set(index, value);
}
inline void SubscribeACK::add_res(::google::protobuf::uint32 value) {
  res_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SubscribeACK::res() const {
  return res_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SubscribeACK::mutable_res() {
  return &res_;
}

// optional string peid_time = 3;
inline bool SubscribeACK::has_peid_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscribeACK::set_has_peid_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscribeACK::clear_has_peid_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscribeACK::clear_peid_time() {
  if (peid_time_ != &::google::protobuf::internal::kEmptyString) {
    peid_time_->clear();
  }
  clear_has_peid_time();
}
inline const ::std::string& SubscribeACK::peid_time() const {
  return *peid_time_;
}
inline void SubscribeACK::set_peid_time(const ::std::string& value) {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  peid_time_->assign(value);
}
inline void SubscribeACK::set_peid_time(const char* value) {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  peid_time_->assign(value);
}
inline void SubscribeACK::set_peid_time(const char* value, size_t size) {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  peid_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeACK::mutable_peid_time() {
  set_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    peid_time_ = new ::std::string;
  }
  return peid_time_;
}
inline ::std::string* SubscribeACK::release_peid_time() {
  clear_has_peid_time();
  if (peid_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peid_time_;
    peid_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string debug_info = 4;
inline bool SubscribeACK::has_debug_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubscribeACK::set_has_debug_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubscribeACK::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubscribeACK::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& SubscribeACK::debug_info() const {
  return *debug_info_;
}
inline void SubscribeACK::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeACK::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeACK::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeACK::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* SubscribeACK::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SubscribeImporterRequest

// repeated string names = 1;
inline int SubscribeImporterRequest::names_size() const {
  return names_.size();
}
inline void SubscribeImporterRequest::clear_names() {
  names_.Clear();
}
inline const ::std::string& SubscribeImporterRequest::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* SubscribeImporterRequest::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void SubscribeImporterRequest::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void SubscribeImporterRequest::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void SubscribeImporterRequest::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeImporterRequest::add_names() {
  return names_.Add();
}
inline void SubscribeImporterRequest::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void SubscribeImporterRequest::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void SubscribeImporterRequest::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubscribeImporterRequest::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubscribeImporterRequest::mutable_names() {
  return &names_;
}

// repeated .dstream.PipeID pipeids = 2;
inline int SubscribeImporterRequest::pipeids_size() const {
  return pipeids_.size();
}
inline void SubscribeImporterRequest::clear_pipeids() {
  pipeids_.Clear();
}
inline const ::dstream::PipeID& SubscribeImporterRequest::pipeids(int index) const {
  return pipeids_.Get(index);
}
inline ::dstream::PipeID* SubscribeImporterRequest::mutable_pipeids(int index) {
  return pipeids_.Mutable(index);
}
inline ::dstream::PipeID* SubscribeImporterRequest::add_pipeids() {
  return pipeids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >&
SubscribeImporterRequest::pipeids() const {
  return pipeids_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PipeID >*
SubscribeImporterRequest::mutable_pipeids() {
  return &pipeids_;
}

// optional string debug_info = 3;
inline bool SubscribeImporterRequest::has_debug_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscribeImporterRequest::set_has_debug_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscribeImporterRequest::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscribeImporterRequest::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& SubscribeImporterRequest::debug_info() const {
  return *debug_info_;
}
inline void SubscribeImporterRequest::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeImporterRequest::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeImporterRequest::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeImporterRequest::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* SubscribeImporterRequest::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SubscribeImporterACK

// optional string debug_info = 1;
inline bool SubscribeImporterACK::has_debug_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImporterACK::set_has_debug_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImporterACK::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImporterACK::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& SubscribeImporterACK::debug_info() const {
  return *debug_info_;
}
inline void SubscribeImporterACK::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeImporterACK::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void SubscribeImporterACK::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeImporterACK::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* SubscribeImporterACK::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HeartbeatRequest

// optional .dstream.PEID peid = 1;
inline bool HeartbeatRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& HeartbeatRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* HeartbeatRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* HeartbeatRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// repeated string metric_name = 2;
inline int HeartbeatRequest::metric_name_size() const {
  return metric_name_.size();
}
inline void HeartbeatRequest::clear_metric_name() {
  metric_name_.Clear();
}
inline const ::std::string& HeartbeatRequest::metric_name(int index) const {
  return metric_name_.Get(index);
}
inline ::std::string* HeartbeatRequest::mutable_metric_name(int index) {
  return metric_name_.Mutable(index);
}
inline void HeartbeatRequest::set_metric_name(int index, const ::std::string& value) {
  metric_name_.Mutable(index)->assign(value);
}
inline void HeartbeatRequest::set_metric_name(int index, const char* value) {
  metric_name_.Mutable(index)->assign(value);
}
inline void HeartbeatRequest::set_metric_name(int index, const char* value, size_t size) {
  metric_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatRequest::add_metric_name() {
  return metric_name_.Add();
}
inline void HeartbeatRequest::add_metric_name(const ::std::string& value) {
  metric_name_.Add()->assign(value);
}
inline void HeartbeatRequest::add_metric_name(const char* value) {
  metric_name_.Add()->assign(value);
}
inline void HeartbeatRequest::add_metric_name(const char* value, size_t size) {
  metric_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartbeatRequest::metric_name() const {
  return metric_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartbeatRequest::mutable_metric_name() {
  return &metric_name_;
}

// repeated string metric_value = 3;
inline int HeartbeatRequest::metric_value_size() const {
  return metric_value_.size();
}
inline void HeartbeatRequest::clear_metric_value() {
  metric_value_.Clear();
}
inline const ::std::string& HeartbeatRequest::metric_value(int index) const {
  return metric_value_.Get(index);
}
inline ::std::string* HeartbeatRequest::mutable_metric_value(int index) {
  return metric_value_.Mutable(index);
}
inline void HeartbeatRequest::set_metric_value(int index, const ::std::string& value) {
  metric_value_.Mutable(index)->assign(value);
}
inline void HeartbeatRequest::set_metric_value(int index, const char* value) {
  metric_value_.Mutable(index)->assign(value);
}
inline void HeartbeatRequest::set_metric_value(int index, const char* value, size_t size) {
  metric_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatRequest::add_metric_value() {
  return metric_value_.Add();
}
inline void HeartbeatRequest::add_metric_value(const ::std::string& value) {
  metric_value_.Add()->assign(value);
}
inline void HeartbeatRequest::add_metric_value(const char* value) {
  metric_value_.Add()->assign(value);
}
inline void HeartbeatRequest::add_metric_value(const char* value, size_t size) {
  metric_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartbeatRequest::metric_value() const {
  return metric_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartbeatRequest::mutable_metric_value() {
  return &metric_value_;
}

// optional string debug_info = 4;
inline bool HeartbeatRequest::has_debug_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartbeatRequest::set_has_debug_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartbeatRequest::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartbeatRequest::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& HeartbeatRequest::debug_info() const {
  return *debug_info_;
}
inline void HeartbeatRequest::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void HeartbeatRequest::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void HeartbeatRequest::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatRequest::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* HeartbeatRequest::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HeartbeatACK

// optional string debug_info = 1;
inline bool HeartbeatACK::has_debug_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatACK::set_has_debug_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatACK::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatACK::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& HeartbeatACK::debug_info() const {
  return *debug_info_;
}
inline void HeartbeatACK::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void HeartbeatACK::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void HeartbeatACK::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatACK::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* HeartbeatACK::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dstream.FlowControl flow_control = 2;
inline bool HeartbeatACK::has_flow_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatACK::set_has_flow_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatACK::clear_has_flow_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatACK::clear_flow_control() {
  if (flow_control_ != NULL) flow_control_->::dstream::FlowControl::Clear();
  clear_has_flow_control();
}
inline const ::dstream::FlowControl& HeartbeatACK::flow_control() const {
  return flow_control_ != NULL ? *flow_control_ : *default_instance_->flow_control_;
}
inline ::dstream::FlowControl* HeartbeatACK::mutable_flow_control() {
  set_has_flow_control();
  if (flow_control_ == NULL) flow_control_ = new ::dstream::FlowControl;
  return flow_control_;
}
inline ::dstream::FlowControl* HeartbeatACK::release_flow_control() {
  clear_has_flow_control();
  ::dstream::FlowControl* temp = flow_control_;
  flow_control_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// TupleMeta

// optional fixed64 hash_code = 1;
inline bool TupleMeta::has_hash_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TupleMeta::set_has_hash_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TupleMeta::clear_has_hash_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TupleMeta::clear_hash_code() {
  hash_code_ = GOOGLE_ULONGLONG(0);
  clear_has_hash_code();
}
inline ::google::protobuf::uint64 TupleMeta::hash_code() const {
  return hash_code_;
}
inline void TupleMeta::set_hash_code(::google::protobuf::uint64 value) {
  set_has_hash_code();
  hash_code_ = value;
}

// optional string tags = 2;
inline bool TupleMeta::has_tags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TupleMeta::set_has_tags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TupleMeta::clear_has_tags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TupleMeta::clear_tags() {
  if (tags_ != &::google::protobuf::internal::kEmptyString) {
    tags_->clear();
  }
  clear_has_tags();
}
inline const ::std::string& TupleMeta::tags() const {
  return *tags_;
}
inline void TupleMeta::set_tags(const ::std::string& value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void TupleMeta::set_tags(const char* value) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(value);
}
inline void TupleMeta::set_tags(const char* value, size_t size) {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TupleMeta::mutable_tags() {
  set_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    tags_ = new ::std::string;
  }
  return tags_;
}
inline ::std::string* TupleMeta::release_tags() {
  clear_has_tags();
  if (tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tags_;
    tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Log

// optional .dstream.PEID upstream_peid = 1;
inline bool Log::has_upstream_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log::set_has_upstream_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log::clear_has_upstream_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log::clear_upstream_peid() {
  if (upstream_peid_ != NULL) upstream_peid_->::dstream::PEID::Clear();
  clear_has_upstream_peid();
}
inline const ::dstream::PEID& Log::upstream_peid() const {
  return upstream_peid_ != NULL ? *upstream_peid_ : *default_instance_->upstream_peid_;
}
inline ::dstream::PEID* Log::mutable_upstream_peid() {
  set_has_upstream_peid();
  if (upstream_peid_ == NULL) upstream_peid_ = new ::dstream::PEID;
  return upstream_peid_;
}
inline ::dstream::PEID* Log::release_upstream_peid() {
  clear_has_upstream_peid();
  ::dstream::PEID* temp = upstream_peid_;
  upstream_peid_ = NULL;
  return temp;
}

// optional .dstream.PipeID upstream_pipeid = 2;
inline bool Log::has_upstream_pipeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_upstream_pipeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_upstream_pipeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_upstream_pipeid() {
  if (upstream_pipeid_ != NULL) upstream_pipeid_->::dstream::PipeID::Clear();
  clear_has_upstream_pipeid();
}
inline const ::dstream::PipeID& Log::upstream_pipeid() const {
  return upstream_pipeid_ != NULL ? *upstream_pipeid_ : *default_instance_->upstream_pipeid_;
}
inline ::dstream::PipeID* Log::mutable_upstream_pipeid() {
  set_has_upstream_pipeid();
  if (upstream_pipeid_ == NULL) upstream_pipeid_ = new ::dstream::PipeID;
  return upstream_pipeid_;
}
inline ::dstream::PipeID* Log::release_upstream_pipeid() {
  clear_has_upstream_pipeid();
  ::dstream::PipeID* temp = upstream_pipeid_;
  upstream_pipeid_ = NULL;
  return temp;
}

// optional .dstream.PipeID pipeid = 11;
inline bool Log::has_pipeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log::set_has_pipeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log::clear_has_pipeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log::clear_pipeid() {
  if (pipeid_ != NULL) pipeid_->::dstream::PipeID::Clear();
  clear_has_pipeid();
}
inline const ::dstream::PipeID& Log::pipeid() const {
  return pipeid_ != NULL ? *pipeid_ : *default_instance_->pipeid_;
}
inline ::dstream::PipeID* Log::mutable_pipeid() {
  set_has_pipeid();
  if (pipeid_ == NULL) pipeid_ = new ::dstream::PipeID;
  return pipeid_;
}
inline ::dstream::PipeID* Log::release_pipeid() {
  clear_has_pipeid();
  ::dstream::PipeID* temp = pipeid_;
  pipeid_ = NULL;
  return temp;
}

// optional .dstream.PEID src_peid = 21;
inline bool Log::has_src_peid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Log::set_has_src_peid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Log::clear_has_src_peid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Log::clear_src_peid() {
  if (src_peid_ != NULL) src_peid_->::dstream::PEID::Clear();
  clear_has_src_peid();
}
inline const ::dstream::PEID& Log::src_peid() const {
  return src_peid_ != NULL ? *src_peid_ : *default_instance_->src_peid_;
}
inline ::dstream::PEID* Log::mutable_src_peid() {
  set_has_src_peid();
  if (src_peid_ == NULL) src_peid_ = new ::dstream::PEID;
  return src_peid_;
}
inline ::dstream::PEID* Log::release_src_peid() {
  clear_has_src_peid();
  ::dstream::PEID* temp = src_peid_;
  src_peid_ = NULL;
  return temp;
}

// optional .dstream.PEID dst_peid = 22;
inline bool Log::has_dst_peid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Log::set_has_dst_peid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Log::clear_has_dst_peid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Log::clear_dst_peid() {
  if (dst_peid_ != NULL) dst_peid_->::dstream::PEID::Clear();
  clear_has_dst_peid();
}
inline const ::dstream::PEID& Log::dst_peid() const {
  return dst_peid_ != NULL ? *dst_peid_ : *default_instance_->dst_peid_;
}
inline ::dstream::PEID* Log::mutable_dst_peid() {
  set_has_dst_peid();
  if (dst_peid_ == NULL) dst_peid_ = new ::dstream::PEID;
  return dst_peid_;
}
inline ::dstream::PEID* Log::release_dst_peid() {
  clear_has_dst_peid();
  ::dstream::PEID* temp = dst_peid_;
  dst_peid_ = NULL;
  return temp;
}

// repeated .dstream.TupleMeta tuples_meta = 31;
inline int Log::tuples_meta_size() const {
  return tuples_meta_.size();
}
inline void Log::clear_tuples_meta() {
  tuples_meta_.Clear();
}
inline const ::dstream::TupleMeta& Log::tuples_meta(int index) const {
  return tuples_meta_.Get(index);
}
inline ::dstream::TupleMeta* Log::mutable_tuples_meta(int index) {
  return tuples_meta_.Mutable(index);
}
inline ::dstream::TupleMeta* Log::add_tuples_meta() {
  return tuples_meta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::TupleMeta >&
Log::tuples_meta() const {
  return tuples_meta_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::TupleMeta >*
Log::mutable_tuples_meta() {
  return &tuples_meta_;
}

// repeated bytes tuples = 32;
inline int Log::tuples_size() const {
  return tuples_.size();
}
inline void Log::clear_tuples() {
  tuples_.Clear();
}
inline const ::std::string& Log::tuples(int index) const {
  return tuples_.Get(index);
}
inline ::std::string* Log::mutable_tuples(int index) {
  return tuples_.Mutable(index);
}
inline void Log::set_tuples(int index, const ::std::string& value) {
  tuples_.Mutable(index)->assign(value);
}
inline void Log::set_tuples(int index, const char* value) {
  tuples_.Mutable(index)->assign(value);
}
inline void Log::set_tuples(int index, const void* value, size_t size) {
  tuples_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Log::add_tuples() {
  return tuples_.Add();
}
inline void Log::add_tuples(const ::std::string& value) {
  tuples_.Add()->assign(value);
}
inline void Log::add_tuples(const char* value) {
  tuples_.Add()->assign(value);
}
inline void Log::add_tuples(const void* value, size_t size) {
  tuples_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Log::tuples() const {
  return tuples_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Log::mutable_tuples() {
  return &tuples_;
}

// optional bytes patch = 33;
inline bool Log::has_patch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Log::set_has_patch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Log::clear_has_patch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Log::clear_patch() {
  if (patch_ != &::google::protobuf::internal::kEmptyString) {
    patch_->clear();
  }
  clear_has_patch();
}
inline const ::std::string& Log::patch() const {
  return *patch_;
}
inline void Log::set_patch(const ::std::string& value) {
  set_has_patch();
  if (patch_ == &::google::protobuf::internal::kEmptyString) {
    patch_ = new ::std::string;
  }
  patch_->assign(value);
}
inline void Log::set_patch(const char* value) {
  set_has_patch();
  if (patch_ == &::google::protobuf::internal::kEmptyString) {
    patch_ = new ::std::string;
  }
  patch_->assign(value);
}
inline void Log::set_patch(const void* value, size_t size) {
  set_has_patch();
  if (patch_ == &::google::protobuf::internal::kEmptyString) {
    patch_ = new ::std::string;
  }
  patch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Log::mutable_patch() {
  set_has_patch();
  if (patch_ == &::google::protobuf::internal::kEmptyString) {
    patch_ = new ::std::string;
  }
  return patch_;
}
inline ::std::string* Log::release_patch() {
  clear_has_patch();
  if (patch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patch_;
    patch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string debug_info = 34;
inline bool Log::has_debug_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Log::set_has_debug_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Log::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Log::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& Log::debug_info() const {
  return *debug_info_;
}
inline void Log::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void Log::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void Log::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Log::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* Log::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FetchLogRequest

// optional .dstream.PEID peid = 1;
inline bool FetchLogRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchLogRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchLogRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchLogRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& FetchLogRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* FetchLogRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* FetchLogRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// optional bool replay_mode = 2;
inline bool FetchLogRequest::has_replay_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchLogRequest::set_has_replay_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchLogRequest::clear_has_replay_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchLogRequest::clear_replay_mode() {
  replay_mode_ = false;
  clear_has_replay_mode();
}
inline bool FetchLogRequest::replay_mode() const {
  return replay_mode_;
}
inline void FetchLogRequest::set_replay_mode(bool value) {
  set_has_replay_mode();
  replay_mode_ = value;
}

// optional string debug_info = 3;
inline bool FetchLogRequest::has_debug_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchLogRequest::set_has_debug_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchLogRequest::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchLogRequest::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& FetchLogRequest::debug_info() const {
  return *debug_info_;
}
inline void FetchLogRequest::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void FetchLogRequest::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void FetchLogRequest::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FetchLogRequest::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* FetchLogRequest::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FetchLogACK

// optional uint64 delay_ms = 1;
inline bool FetchLogACK::has_delay_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchLogACK::set_has_delay_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchLogACK::clear_has_delay_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchLogACK::clear_delay_ms() {
  delay_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_delay_ms();
}
inline ::google::protobuf::uint64 FetchLogACK::delay_ms() const {
  return delay_ms_;
}
inline void FetchLogACK::set_delay_ms(::google::protobuf::uint64 value) {
  set_has_delay_ms();
  delay_ms_ = value;
}

// optional .dstream.Log log = 2;
inline bool FetchLogACK::has_log() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchLogACK::set_has_log() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchLogACK::clear_has_log() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchLogACK::clear_log() {
  if (log_ != NULL) log_->::dstream::Log::Clear();
  clear_has_log();
}
inline const ::dstream::Log& FetchLogACK::log() const {
  return log_ != NULL ? *log_ : *default_instance_->log_;
}
inline ::dstream::Log* FetchLogACK::mutable_log() {
  set_has_log();
  if (log_ == NULL) log_ = new ::dstream::Log;
  return log_;
}
inline ::dstream::Log* FetchLogACK::release_log() {
  clear_has_log();
  ::dstream::Log* temp = log_;
  log_ = NULL;
  return temp;
}

// optional bool end_replay = 3;
inline bool FetchLogACK::has_end_replay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchLogACK::set_has_end_replay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchLogACK::clear_has_end_replay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchLogACK::clear_end_replay() {
  end_replay_ = false;
  clear_has_end_replay();
}
inline bool FetchLogACK::end_replay() const {
  return end_replay_;
}
inline void FetchLogACK::set_end_replay(bool value) {
  set_has_end_replay();
  end_replay_ = value;
}

// optional fixed32 res = 4;
inline bool FetchLogACK::has_res() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchLogACK::set_has_res() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchLogACK::clear_has_res() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchLogACK::clear_res() {
  res_ = 0u;
  clear_has_res();
}
inline ::google::protobuf::uint32 FetchLogACK::res() const {
  return res_;
}
inline void FetchLogACK::set_res(::google::protobuf::uint32 value) {
  set_has_res();
  res_ = value;
}

// optional string debug_info = 5;
inline bool FetchLogACK::has_debug_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchLogACK::set_has_debug_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchLogACK::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchLogACK::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& FetchLogACK::debug_info() const {
  return *debug_info_;
}
inline void FetchLogACK::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void FetchLogACK::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void FetchLogACK::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FetchLogACK::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* FetchLogACK::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ForwardLogRequest

// optional .dstream.PEID peid = 1;
inline bool ForwardLogRequest::has_peid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForwardLogRequest::set_has_peid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForwardLogRequest::clear_has_peid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForwardLogRequest::clear_peid() {
  if (peid_ != NULL) peid_->::dstream::PEID::Clear();
  clear_has_peid();
}
inline const ::dstream::PEID& ForwardLogRequest::peid() const {
  return peid_ != NULL ? *peid_ : *default_instance_->peid_;
}
inline ::dstream::PEID* ForwardLogRequest::mutable_peid() {
  set_has_peid();
  if (peid_ == NULL) peid_ = new ::dstream::PEID;
  return peid_;
}
inline ::dstream::PEID* ForwardLogRequest::release_peid() {
  clear_has_peid();
  ::dstream::PEID* temp = peid_;
  peid_ = NULL;
  return temp;
}

// optional .dstream.Log log = 2;
inline bool ForwardLogRequest::has_log() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForwardLogRequest::set_has_log() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForwardLogRequest::clear_has_log() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForwardLogRequest::clear_log() {
  if (log_ != NULL) log_->::dstream::Log::Clear();
  clear_has_log();
}
inline const ::dstream::Log& ForwardLogRequest::log() const {
  return log_ != NULL ? *log_ : *default_instance_->log_;
}
inline ::dstream::Log* ForwardLogRequest::mutable_log() {
  set_has_log();
  if (log_ == NULL) log_ = new ::dstream::Log;
  return log_;
}
inline ::dstream::Log* ForwardLogRequest::release_log() {
  clear_has_log();
  ::dstream::Log* temp = log_;
  log_ = NULL;
  return temp;
}

// optional string debug_info = 3;
inline bool ForwardLogRequest::has_debug_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForwardLogRequest::set_has_debug_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForwardLogRequest::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForwardLogRequest::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& ForwardLogRequest::debug_info() const {
  return *debug_info_;
}
inline void ForwardLogRequest::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void ForwardLogRequest::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void ForwardLogRequest::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForwardLogRequest::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* ForwardLogRequest::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ForwardLogACK

// optional string debug_info = 1;
inline bool ForwardLogACK::has_debug_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForwardLogACK::set_has_debug_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForwardLogACK::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForwardLogACK::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& ForwardLogACK::debug_info() const {
  return *debug_info_;
}
inline void ForwardLogACK::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void ForwardLogACK::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void ForwardLogACK::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForwardLogACK::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* ForwardLogACK::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 2;
inline bool ForwardLogACK::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForwardLogACK::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForwardLogACK::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForwardLogACK::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ForwardLogACK::status() const {
  return status_;
}
inline void ForwardLogACK::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dstream

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pub_5fsub_2eproto__INCLUDED

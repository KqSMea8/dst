// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pn.proto

#ifndef PROTOBUF_pn_2eproto__INCLUDED
#define PROTOBUF_pn_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "dstream_proto_common.pb.h"
// @@protoc_insertion_point(includes)

namespace dstream {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pn_2eproto();
void protobuf_AssignDesc_pn_2eproto();
void protobuf_ShutdownFile_pn_2eproto();

class PN;
class PEWrapperKV;
class PEWrapperMapPB;

enum PNStatus {
  NORMAL = 0,
  DECOSSIMION = 2
};
bool PNStatus_IsValid(int value);
const PNStatus PNStatus_MIN = NORMAL;
const PNStatus PNStatus_MAX = DECOSSIMION;
const int PNStatus_ARRAYSIZE = PNStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PNStatus_descriptor();
inline const ::std::string& PNStatus_Name(PNStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PNStatus_descriptor(), value);
}
inline bool PNStatus_Parse(
    const ::std::string& name, PNStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PNStatus>(
    PNStatus_descriptor(), name, value);
}
// ===================================================================

class PN : public ::google::protobuf::Message {
 public:
  PN();
  virtual ~PN();
  
  PN(const PN& from);
  
  inline PN& operator=(const PN& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PN& default_instance();
  
  void Swap(PN* other);
  
  // implements Message ----------------------------------------------
  
  PN* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PN& from);
  void MergeFrom(const PN& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dstream.PNID pn_id = 1;
  inline bool has_pn_id() const;
  inline void clear_pn_id();
  static const int kPnIdFieldNumber = 1;
  inline const ::dstream::PNID& pn_id() const;
  inline ::dstream::PNID* mutable_pn_id();
  inline ::dstream::PNID* release_pn_id();
  
  // optional string host = 2;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 2;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  
  // optional fixed32 rpc_server_port = 3;
  inline bool has_rpc_server_port() const;
  inline void clear_rpc_server_port();
  static const int kRpcServerPortFieldNumber = 3;
  inline ::google::protobuf::uint32 rpc_server_port() const;
  inline void set_rpc_server_port(::google::protobuf::uint32 value);
  
  // optional fixed32 pub_port = 4;
  inline bool has_pub_port() const;
  inline void clear_pub_port();
  static const int kPubPortFieldNumber = 4;
  inline ::google::protobuf::uint32 pub_port() const;
  inline void set_pub_port(::google::protobuf::uint32 value);
  
  // optional fixed32 sub_port = 5;
  inline bool has_sub_port() const;
  inline void clear_sub_port();
  static const int kSubPortFieldNumber = 5;
  inline ::google::protobuf::uint32 sub_port() const;
  inline void set_sub_port(::google::protobuf::uint32 value);
  
  // optional fixed32 importer_port = 6;
  inline bool has_importer_port() const;
  inline void clear_importer_port();
  static const int kImporterPortFieldNumber = 6;
  inline ::google::protobuf::uint32 importer_port() const;
  inline void set_importer_port(::google::protobuf::uint32 value);
  
  // optional .dstream.PNStatus status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline dstream::PNStatus status() const;
  inline void set_status(dstream::PNStatus value);
  
  // optional fixed32 debug_port = 8;
  inline bool has_debug_port() const;
  inline void clear_debug_port();
  static const int kDebugPortFieldNumber = 8;
  inline ::google::protobuf::uint32 debug_port() const;
  inline void set_debug_port(::google::protobuf::uint32 value);
  
  // optional string version = 9;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 9;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional fixed32 httpd_port = 10;
  inline bool has_httpd_port() const;
  inline void clear_httpd_port();
  static const int kHttpdPortFieldNumber = 10;
  inline ::google::protobuf::uint32 httpd_port() const;
  inline void set_httpd_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.PN)
 private:
  inline void set_has_pn_id();
  inline void clear_has_pn_id();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_rpc_server_port();
  inline void clear_has_rpc_server_port();
  inline void set_has_pub_port();
  inline void clear_has_pub_port();
  inline void set_has_sub_port();
  inline void clear_has_sub_port();
  inline void set_has_importer_port();
  inline void clear_has_importer_port();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_debug_port();
  inline void clear_has_debug_port();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_httpd_port();
  inline void clear_has_httpd_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dstream::PNID* pn_id_;
  ::std::string* host_;
  ::google::protobuf::uint32 rpc_server_port_;
  ::google::protobuf::uint32 pub_port_;
  ::google::protobuf::uint32 sub_port_;
  ::google::protobuf::uint32 importer_port_;
  int status_;
  ::google::protobuf::uint32 debug_port_;
  ::std::string* version_;
  ::google::protobuf::uint32 httpd_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_pn_2eproto();
  friend void protobuf_AssignDesc_pn_2eproto();
  friend void protobuf_ShutdownFile_pn_2eproto();
  
  void InitAsDefaultInstance();
  static PN* default_instance_;
};
// -------------------------------------------------------------------

class PEWrapperKV : public ::google::protobuf::Message {
 public:
  PEWrapperKV();
  virtual ~PEWrapperKV();
  
  PEWrapperKV(const PEWrapperKV& from);
  
  inline PEWrapperKV& operator=(const PEWrapperKV& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PEWrapperKV& default_instance();
  
  void Swap(PEWrapperKV* other);
  
  // implements Message ----------------------------------------------
  
  PEWrapperKV* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PEWrapperKV& from);
  void MergeFrom(const PEWrapperKV& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 pe_id = 1;
  inline bool has_pe_id() const;
  inline void clear_pe_id();
  static const int kPeIdFieldNumber = 1;
  inline ::google::protobuf::uint64 pe_id() const;
  inline void set_pe_id(::google::protobuf::uint64 value);
  
  // optional fixed32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint64 assign_time = 3;
  inline bool has_assign_time() const;
  inline void clear_assign_time();
  static const int kAssignTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 assign_time() const;
  inline void set_assign_time(::google::protobuf::uint64 value);
  
  // optional string app_name = 4;
  inline bool has_app_name() const;
  inline void clear_app_name();
  static const int kAppNameFieldNumber = 4;
  inline const ::std::string& app_name() const;
  inline void set_app_name(const ::std::string& value);
  inline void set_app_name(const char* value);
  inline void set_app_name(const char* value, size_t size);
  inline ::std::string* mutable_app_name();
  inline ::std::string* release_app_name();
  
  // optional fixed32 revision = 5;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 5;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:dstream.PEWrapperKV)
 private:
  inline void set_has_pe_id();
  inline void clear_has_pe_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_assign_time();
  inline void clear_has_assign_time();
  inline void set_has_app_name();
  inline void clear_has_app_name();
  inline void set_has_revision();
  inline void clear_has_revision();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 pe_id_;
  ::google::protobuf::uint64 assign_time_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 revision_;
  ::std::string* app_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pn_2eproto();
  friend void protobuf_AssignDesc_pn_2eproto();
  friend void protobuf_ShutdownFile_pn_2eproto();
  
  void InitAsDefaultInstance();
  static PEWrapperKV* default_instance_;
};
// -------------------------------------------------------------------

class PEWrapperMapPB : public ::google::protobuf::Message {
 public:
  PEWrapperMapPB();
  virtual ~PEWrapperMapPB();
  
  PEWrapperMapPB(const PEWrapperMapPB& from);
  
  inline PEWrapperMapPB& operator=(const PEWrapperMapPB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PEWrapperMapPB& default_instance();
  
  void Swap(PEWrapperMapPB* other);
  
  // implements Message ----------------------------------------------
  
  PEWrapperMapPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PEWrapperMapPB& from);
  void MergeFrom(const PEWrapperMapPB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dstream.PEWrapperKV normal_pe_kv = 1;
  inline int normal_pe_kv_size() const;
  inline void clear_normal_pe_kv();
  static const int kNormalPeKvFieldNumber = 1;
  inline const ::dstream::PEWrapperKV& normal_pe_kv(int index) const;
  inline ::dstream::PEWrapperKV* mutable_normal_pe_kv(int index);
  inline ::dstream::PEWrapperKV* add_normal_pe_kv();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >&
      normal_pe_kv() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >*
      mutable_normal_pe_kv();
  
  // repeated .dstream.PEWrapperKV fail_pe_kv = 2;
  inline int fail_pe_kv_size() const;
  inline void clear_fail_pe_kv();
  static const int kFailPeKvFieldNumber = 2;
  inline const ::dstream::PEWrapperKV& fail_pe_kv(int index) const;
  inline ::dstream::PEWrapperKV* mutable_fail_pe_kv(int index);
  inline ::dstream::PEWrapperKV* add_fail_pe_kv();
  inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >&
      fail_pe_kv() const;
  inline ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >*
      mutable_fail_pe_kv();
  
  // @@protoc_insertion_point(class_scope:dstream.PEWrapperMapPB)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV > normal_pe_kv_;
  ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV > fail_pe_kv_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pn_2eproto();
  friend void protobuf_AssignDesc_pn_2eproto();
  friend void protobuf_ShutdownFile_pn_2eproto();
  
  void InitAsDefaultInstance();
  static PEWrapperMapPB* default_instance_;
};
// ===================================================================


// ===================================================================

// PN

// optional .dstream.PNID pn_id = 1;
inline bool PN::has_pn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PN::set_has_pn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PN::clear_has_pn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PN::clear_pn_id() {
  if (pn_id_ != NULL) pn_id_->::dstream::PNID::Clear();
  clear_has_pn_id();
}
inline const ::dstream::PNID& PN::pn_id() const {
  return pn_id_ != NULL ? *pn_id_ : *default_instance_->pn_id_;
}
inline ::dstream::PNID* PN::mutable_pn_id() {
  set_has_pn_id();
  if (pn_id_ == NULL) pn_id_ = new ::dstream::PNID;
  return pn_id_;
}
inline ::dstream::PNID* PN::release_pn_id() {
  clear_has_pn_id();
  ::dstream::PNID* temp = pn_id_;
  pn_id_ = NULL;
  return temp;
}

// optional string host = 2;
inline bool PN::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PN::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PN::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PN::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& PN::host() const {
  return *host_;
}
inline void PN::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void PN::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void PN::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PN::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* PN::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 rpc_server_port = 3;
inline bool PN::has_rpc_server_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PN::set_has_rpc_server_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PN::clear_has_rpc_server_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PN::clear_rpc_server_port() {
  rpc_server_port_ = 0u;
  clear_has_rpc_server_port();
}
inline ::google::protobuf::uint32 PN::rpc_server_port() const {
  return rpc_server_port_;
}
inline void PN::set_rpc_server_port(::google::protobuf::uint32 value) {
  set_has_rpc_server_port();
  rpc_server_port_ = value;
}

// optional fixed32 pub_port = 4;
inline bool PN::has_pub_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PN::set_has_pub_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PN::clear_has_pub_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PN::clear_pub_port() {
  pub_port_ = 0u;
  clear_has_pub_port();
}
inline ::google::protobuf::uint32 PN::pub_port() const {
  return pub_port_;
}
inline void PN::set_pub_port(::google::protobuf::uint32 value) {
  set_has_pub_port();
  pub_port_ = value;
}

// optional fixed32 sub_port = 5;
inline bool PN::has_sub_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PN::set_has_sub_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PN::clear_has_sub_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PN::clear_sub_port() {
  sub_port_ = 0u;
  clear_has_sub_port();
}
inline ::google::protobuf::uint32 PN::sub_port() const {
  return sub_port_;
}
inline void PN::set_sub_port(::google::protobuf::uint32 value) {
  set_has_sub_port();
  sub_port_ = value;
}

// optional fixed32 importer_port = 6;
inline bool PN::has_importer_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PN::set_has_importer_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PN::clear_has_importer_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PN::clear_importer_port() {
  importer_port_ = 0u;
  clear_has_importer_port();
}
inline ::google::protobuf::uint32 PN::importer_port() const {
  return importer_port_;
}
inline void PN::set_importer_port(::google::protobuf::uint32 value) {
  set_has_importer_port();
  importer_port_ = value;
}

// optional .dstream.PNStatus status = 7;
inline bool PN::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PN::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PN::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PN::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline dstream::PNStatus PN::status() const {
  return static_cast< dstream::PNStatus >(status_);
}
inline void PN::set_status(dstream::PNStatus value) {
  GOOGLE_DCHECK(dstream::PNStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional fixed32 debug_port = 8;
inline bool PN::has_debug_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PN::set_has_debug_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PN::clear_has_debug_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PN::clear_debug_port() {
  debug_port_ = 0u;
  clear_has_debug_port();
}
inline ::google::protobuf::uint32 PN::debug_port() const {
  return debug_port_;
}
inline void PN::set_debug_port(::google::protobuf::uint32 value) {
  set_has_debug_port();
  debug_port_ = value;
}

// optional string version = 9;
inline bool PN::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PN::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PN::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PN::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& PN::version() const {
  return *version_;
}
inline void PN::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void PN::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void PN::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PN::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* PN::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 httpd_port = 10;
inline bool PN::has_httpd_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PN::set_has_httpd_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PN::clear_has_httpd_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PN::clear_httpd_port() {
  httpd_port_ = 0u;
  clear_has_httpd_port();
}
inline ::google::protobuf::uint32 PN::httpd_port() const {
  return httpd_port_;
}
inline void PN::set_httpd_port(::google::protobuf::uint32 value) {
  set_has_httpd_port();
  httpd_port_ = value;
}

// -------------------------------------------------------------------

// PEWrapperKV

// optional fixed64 pe_id = 1;
inline bool PEWrapperKV::has_pe_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PEWrapperKV::set_has_pe_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PEWrapperKV::clear_has_pe_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PEWrapperKV::clear_pe_id() {
  pe_id_ = GOOGLE_ULONGLONG(0);
  clear_has_pe_id();
}
inline ::google::protobuf::uint64 PEWrapperKV::pe_id() const {
  return pe_id_;
}
inline void PEWrapperKV::set_pe_id(::google::protobuf::uint64 value) {
  set_has_pe_id();
  pe_id_ = value;
}

// optional fixed32 type = 2;
inline bool PEWrapperKV::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PEWrapperKV::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PEWrapperKV::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PEWrapperKV::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 PEWrapperKV::type() const {
  return type_;
}
inline void PEWrapperKV::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 assign_time = 3;
inline bool PEWrapperKV::has_assign_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PEWrapperKV::set_has_assign_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PEWrapperKV::clear_has_assign_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PEWrapperKV::clear_assign_time() {
  assign_time_ = GOOGLE_ULONGLONG(0);
  clear_has_assign_time();
}
inline ::google::protobuf::uint64 PEWrapperKV::assign_time() const {
  return assign_time_;
}
inline void PEWrapperKV::set_assign_time(::google::protobuf::uint64 value) {
  set_has_assign_time();
  assign_time_ = value;
}

// optional string app_name = 4;
inline bool PEWrapperKV::has_app_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PEWrapperKV::set_has_app_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PEWrapperKV::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PEWrapperKV::clear_app_name() {
  if (app_name_ != &::google::protobuf::internal::kEmptyString) {
    app_name_->clear();
  }
  clear_has_app_name();
}
inline const ::std::string& PEWrapperKV::app_name() const {
  return *app_name_;
}
inline void PEWrapperKV::set_app_name(const ::std::string& value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void PEWrapperKV::set_app_name(const char* value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void PEWrapperKV::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PEWrapperKV::mutable_app_name() {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  return app_name_;
}
inline ::std::string* PEWrapperKV::release_app_name() {
  clear_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_name_;
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed32 revision = 5;
inline bool PEWrapperKV::has_revision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PEWrapperKV::set_has_revision() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PEWrapperKV::clear_has_revision() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PEWrapperKV::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 PEWrapperKV::revision() const {
  return revision_;
}
inline void PEWrapperKV::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// PEWrapperMapPB

// repeated .dstream.PEWrapperKV normal_pe_kv = 1;
inline int PEWrapperMapPB::normal_pe_kv_size() const {
  return normal_pe_kv_.size();
}
inline void PEWrapperMapPB::clear_normal_pe_kv() {
  normal_pe_kv_.Clear();
}
inline const ::dstream::PEWrapperKV& PEWrapperMapPB::normal_pe_kv(int index) const {
  return normal_pe_kv_.Get(index);
}
inline ::dstream::PEWrapperKV* PEWrapperMapPB::mutable_normal_pe_kv(int index) {
  return normal_pe_kv_.Mutable(index);
}
inline ::dstream::PEWrapperKV* PEWrapperMapPB::add_normal_pe_kv() {
  return normal_pe_kv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >&
PEWrapperMapPB::normal_pe_kv() const {
  return normal_pe_kv_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >*
PEWrapperMapPB::mutable_normal_pe_kv() {
  return &normal_pe_kv_;
}

// repeated .dstream.PEWrapperKV fail_pe_kv = 2;
inline int PEWrapperMapPB::fail_pe_kv_size() const {
  return fail_pe_kv_.size();
}
inline void PEWrapperMapPB::clear_fail_pe_kv() {
  fail_pe_kv_.Clear();
}
inline const ::dstream::PEWrapperKV& PEWrapperMapPB::fail_pe_kv(int index) const {
  return fail_pe_kv_.Get(index);
}
inline ::dstream::PEWrapperKV* PEWrapperMapPB::mutable_fail_pe_kv(int index) {
  return fail_pe_kv_.Mutable(index);
}
inline ::dstream::PEWrapperKV* PEWrapperMapPB::add_fail_pe_kv() {
  return fail_pe_kv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >&
PEWrapperMapPB::fail_pe_kv() const {
  return fail_pe_kv_;
}
inline ::google::protobuf::RepeatedPtrField< ::dstream::PEWrapperKV >*
PEWrapperMapPB::mutable_fail_pe_kv() {
  return &fail_pe_kv_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dstream

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< dstream::PNStatus>() {
  return dstream::PNStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pn_2eproto__INCLUDED

#include "bigpipe_publisher.h"
#include "bigpipe_async_publisher.h"
#include "bigpipe_api_factory.h"
#include "common_log.h"
#include "common_return_type.h"
#include "common_util.h"
#include "common_sleeper.h"
#include <pthread.h>
#include <time.h>
#include <stdlib.h>

using namespace bigpipe;

/**
 * @brief 工具参数
 */
char producer_type[16] = ""; // pub means sync, apub means async
char pipe_name[128] = "";
int pipelet_num = 0;
int pipelet_id = -1;
int msg_cnt = -1;
int msg_size_max = 100;
int msg_size_min = 100;
int thread_mode = 1; // 1 mans multi-thread, 0 means single
char magic_str[128] = "";

/**
 * @brief 使用方法
 */
void usage()
{
    printf("\n============================\n");
    printf("./pub send_type:pipe_name:pipelet_num:pipelet_id:msg_cnt:msg_size:thread_mode:magic\n");
    printf("============================\n\n");

    printf("   send_type : pub means sync publisher; apub means aysnc\n");
    printf(" pipelet_num : the total pipelets in indicated pipe\n");
    printf("  pipelet_id : if set to -1, send msgs to all pipelets\n");
    printf("     msg_cnt : if msg_cnt set to -1, the sending won't stop\n");
    printf("    msg_size : formet is : a-b, if a != b, will generate random size between a-b\n");
    printf(" thread_mode : if set to 0, use single thread to send one pipe; if set to 1, use one thread for each pipelet\n");
    printf("       magic : use this magic str to fill message body, magic number can use to identify a data source\n");
    printf("\n\n\n=======example as follow=========\n");
    printf(" ./pub pub:pipe1:-1:1000000:400-600:1:data_source1\n");
    printf(" ./pub pub:pipe1:-1:1000000:500-500:0:data_source2\n");
    printf("\n\n the message generated by producer looks like this:\n");
    printf(" \"pipelet_id:sequence_num:send_time:magic:receive_time\" ==>");
    printf(" the consumer will append the receive time to message after the magic \n\n\n\n\n");
    exit(-1);
}

/**
 * @brief send pipelet
 */
void* send_work(void* args)
{
    int ret = BIGPIPE_E_OK;
    int pipeletId = (int)(long)(args);

    // progress 和 partitioner
    bigpipe_progress_t prog;
    bigpipe_partitioner_t pt;

    char message[2 * 1024 * 1024 + 1024];
    memset(message, '#', sizeof(message));

    bigpipe_publisher_t publisher;
    bigpipe_async_publisher_t async_publisher;
    bigpipe_publisher_t* pub = 0;

    // 使用哪种发送方式
    if (0 == strcmp("pub", producer_type))
    {
        pub = &publisher;
    }
    else if (0 == strcmp("apub", producer_type))
    {
        pub = &async_publisher;
    }
    else
    {
        usage();
    }

    sleep(1);
    printf("start send work on pipelet-%d\n", pipeletId);

    // 初始化
    ret = publisher.init(pipe_name, &pt /* partition */, "./conf", "pub.conf");
    if (BIGPIPE_E_OK != ret)
    {
        printf("publisher init failed [pipelet_id : %d]\n", pipeletId);
        return 0;
    }
    printf("publisher init success [pipelet_id : %d]\n", pipeletId);

    // 连接
    ret = publisher.connect();
    if (BIGPIPE_E_OK != ret)
    {
        printf("publisher connect failed [pipelet_id : %d]\n", pipeletId);
        return 0;
    }
    printf("publisher connect success [pipelet_id : %d]\n", pipeletId);

    bool stop_flag = false;

    printf(" in sending ... [pipelet_id : %d]\n", pipeletId);
    for ( int sequence = 1; stop_flag != true; sequence++ )
    {
        struct timeval cur_time;
        gettimeofday(&cur_time, NULL);
        uint32_t micro_sec = (cur_time.tv_sec % (3600 * 24)) * 1000 + cur_time.tv_usec / 1000; // ms

        srand((unsigned int)time(NULL));
        int msg_size = msg_size_min;
        if (msg_size_min != msg_size_max)
        {
            msg_size += rand() % (msg_size_max - msg_size_min);
        }

        if (-1 == pipeletId)
        {
            for (int id = 0; id < pipelet_num; id++)
            {
                memset(message, (int)'#', 100);
                //sprintf(message, "%d:%d:%u:%s:",id,sequence,micro_sec,magic_str);
                sprintf(message, "%d:", sequence);

                //printf(" -- sending pipelet: %d, seq: %d\n", id, sequence);
                ret = publisher.batch_send_one(id, message, msg_size, NULL);

                if (BIGPIPE_E_OK != ret)
                {
                    BIGPIPE_LOG_FATAL("[pub] publisher send failed [pipelet_id : %d]\n", id);
                    stop_flag = true;
                    continue;
                }
            }
        }
        else
        {
            memset(message, (int)'#', 100);
            //sprintf(message, "%d:%d:%u:%s:",pipeletId,sequence,micro_sec,magic_str);
            sprintf(message, "%d:", sequence);

            //printf(" -- sending pipelet: %d, seq: %d\n", pipeletId, sequence);
            ret = publisher.batch_send_one(pipeletId, message, msg_size, NULL);

            if (BIGPIPE_E_OK != ret)
            {
                BIGPIPE_LOG_FATAL("[pub] publisher send failed [pipelet_id : %d]\n", pipeletId);
                stop_flag = true;
                continue;
            }
        }
        if (-1 != msg_cnt && msg_cnt == sequence)
        {
            stop_flag = true;
            BIGPIPE_LOG_WARNING("[pub] publisher reaches max msg_num [pipelet_id : %d]\n", pipeletId);
        }
    }

    ret =  publisher.disconnect();
    if (BIGPIPE_E_OK != ret)
    {
        BIGPIPE_LOG_FATAL("[pub] disconnect failed [pipelet_id : %d]\n", pipeletId);
        return 0;
    }
    printf("disconnect success [pipelet_id : %d]\n", pipeletId);

    return 0;
}

/**
 * @brief 入口
 */
int main(int argc, char* argv[])
{
    // 忽略SIGPIPE信号
    struct sigaction action;
    action.sa_handler = SIG_IGN;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    sigaction(SIGPIPE, &action, NULL);

    // 打印用法
    if (2 != argc)
    {
        usage();
    }

    // 加载配置
    BIGPIPE_LOAD_LOG("./conf", "pub.conf");

    // 解析工具参数
    char temp_str[64] = "";
    for (int i = 0; i < strlen(argv[1]); i++)
    {
        if (':' == argv[1][i]) {
            argv[1][i] = ' ';
        }
    }
    printf("%s\n", argv[1]);
    sscanf(argv[1], "%s%s%d%d%d%s%d%s", producer_type, pipe_name, &pipelet_num, &pipelet_id, &msg_cnt,
           temp_str, &thread_mode, magic_str);
    sscanf(temp_str, "%d-%d", &msg_size_min, &msg_size_max);
    printf("producer_type: %s\n", producer_type);
    printf("pipe_name: %s\n", pipe_name);
    printf("pipelet_num: %d\n", pipelet_num);
    printf("pipelet_id: %d\n", pipelet_id);
    printf("msg_size_min: %d\n", msg_size_min);
    printf("msg_size_max: %d\n", msg_size_max);
    printf("thread_mode: %d\n", thread_mode);
    printf("magic_str: %s\n\n", magic_str);
    printf("===================================================> let's go!!!\n\n\n");

    // 开始
    pthread_t work_thread[PTHREAD_THREADS_MAX];
    if ( 1 == thread_mode )
    {
        if ( -1 == pipelet_id )
        {
            for (int i = 0; i < pipelet_num; ++i)
            {
                printf("start piplelet-%d send thread ...\n", i);
                pthread_create(work_thread + i, NULL, send_work, (void*)(long)i);
                printf("start piplelet-%d send thread (done)\n", i);
            }
            for (int i = 0; i < pipelet_num; ++i)
            {
                pthread_join(work_thread[i], NULL);
                printf("piplelet-%d send thread (end)\n", i);
            }
        }
        else
        {
            send_work((void*)(long)pipelet_id);
        }
    }
    else
    {
        send_work((void*)(long)pipelet_id);
    }

    BIGPIPE_CLOSE_LOG();

    return 0;
}
